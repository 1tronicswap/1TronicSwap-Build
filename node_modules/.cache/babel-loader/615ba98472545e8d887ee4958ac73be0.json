{"ast":null,"code":"import invariant from 'tiny-invariant';\nimport { ChainId } from '../constants';\nimport { validateAndParseAddress } from '../utils';\nimport { Currency } from './currency';\n/**\r\n * Represents an ERC20 token with a unique address and some metadata.\r\n */\n\nexport class Token extends Currency {\n  constructor(chainId, address, decimals, symbol, name) {\n    super(decimals, symbol, name);\n    this.chainId = void 0;\n    this.address = void 0;\n    this.chainId = chainId;\n    this.address = validateAndParseAddress(address);\n  }\n  /**\r\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\r\n   * @param other other token to compare\r\n   */\n\n\n  equals(other) {\n    // short circuit on reference equality\n    if (this === other) {\n      return true;\n    }\n\n    return this.chainId === other.chainId && this.address === other.address;\n  }\n  /**\r\n   * Returns true if the address of this token sorts before the address of the other token\r\n   * @param other other token to compare\r\n   * @throws if the tokens have the same address\r\n   * @throws if the tokens are on different chains\r\n   */\n\n\n  sortsBefore(other) {\n    invariant(this.chainId === other.chainId, 'CHAIN_IDS');\n    invariant(this.address !== other.address, 'ADDRESSES');\n    return this.address.toLowerCase() < other.address.toLowerCase();\n  }\n\n}\n/**\r\n * Compares two currencies for equality\r\n */\n\nexport function currencyEquals(currencyA, currencyB) {\n  if (currencyA instanceof Token && currencyB instanceof Token) {\n    return currencyA.equals(currencyB);\n  } else if (currencyA instanceof Token) {\n    return false;\n  } else if (currencyB instanceof Token) {\n    return false;\n  } else {\n    return currencyA === currencyB;\n  }\n}\nexport const WETH = {\n  [ChainId.MAINNET]: new Token(ChainId.MAINNET, '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', 18, 'WBNB', 'Wrapped BNB'),\n  [ChainId.TESTNET]: new Token(ChainId.TESTNET, '0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd', 18, 'WBNB', 'Wrapped BNB')\n};","map":{"version":3,"sources":["D:/new/1TronicSwap-Build/src/utils/@sdk/entities/token.ts"],"names":["invariant","ChainId","validateAndParseAddress","Currency","Token","constructor","chainId","address","decimals","symbol","name","equals","other","sortsBefore","toLowerCase","currencyEquals","currencyA","currencyB","WETH","MAINNET","TESTNET"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,gBAAtB;AACA,SAASC,OAAT,QAAwB,cAAxB;AACA,SAASC,uBAAT,QAAwC,UAAxC;AACA,SAASC,QAAT,QAAyB,YAAzB;AAEA;AACA;AACA;;AACA,OAAO,MAAMC,KAAN,SAAoBD,QAApB,CAA6B;AAI3BE,EAAAA,WAAW,CAACC,OAAD,EAAmBC,OAAnB,EAAoCC,QAApC,EAAsDC,MAAtD,EAAuEC,IAAvE,EAAsF;AACtG,UAAMF,QAAN,EAAgBC,MAAhB,EAAwBC,IAAxB;AADsG,SAHxFJ,OAGwF;AAAA,SAFxFC,OAEwF;AAEtG,SAAKD,OAAL,GAAeA,OAAf;AACA,SAAKC,OAAL,GAAeL,uBAAuB,CAACK,OAAD,CAAtC;AACD;AAED;AACF;AACA;AACA;;;AACSI,EAAAA,MAAM,CAACC,KAAD,EAAwB;AACnC;AACA,QAAI,SAASA,KAAb,EAAoB;AAClB,aAAO,IAAP;AACD;;AACD,WAAO,KAAKN,OAAL,KAAiBM,KAAK,CAACN,OAAvB,IAAkC,KAAKC,OAAL,KAAiBK,KAAK,CAACL,OAAhE;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACSM,EAAAA,WAAW,CAACD,KAAD,EAAwB;AACxCZ,IAAAA,SAAS,CAAC,KAAKM,OAAL,KAAiBM,KAAK,CAACN,OAAxB,EAAiC,WAAjC,CAAT;AACAN,IAAAA,SAAS,CAAC,KAAKO,OAAL,KAAiBK,KAAK,CAACL,OAAxB,EAAiC,WAAjC,CAAT;AACA,WAAO,KAAKA,OAAL,CAAaO,WAAb,KAA6BF,KAAK,CAACL,OAAN,CAAcO,WAAd,EAApC;AACD;;AAhCiC;AAmCpC;AACA;AACA;;AACA,OAAO,SAASC,cAAT,CAAwBC,SAAxB,EAA6CC,SAA7C,EAA2E;AAChF,MAAID,SAAS,YAAYZ,KAArB,IAA8Ba,SAAS,YAAYb,KAAvD,EAA8D;AAC5D,WAAOY,SAAS,CAACL,MAAV,CAAiBM,SAAjB,CAAP;AACD,GAFD,MAEO,IAAID,SAAS,YAAYZ,KAAzB,EAAgC;AACrC,WAAO,KAAP;AACD,GAFM,MAEA,IAAIa,SAAS,YAAYb,KAAzB,EAAgC;AACrC,WAAO,KAAP;AACD,GAFM,MAEA;AACL,WAAOY,SAAS,KAAKC,SAArB;AACD;AACF;AAED,OAAO,MAAMC,IAAI,GAAG;AAClB,GAACjB,OAAO,CAACkB,OAAT,GAAmB,IAAIf,KAAJ,CACjBH,OAAO,CAACkB,OADS,EAEjB,4CAFiB,EAGjB,EAHiB,EAIjB,MAJiB,EAKjB,aALiB,CADD;AAQlB,GAAClB,OAAO,CAACmB,OAAT,GAAmB,IAAIhB,KAAJ,CACjBH,OAAO,CAACmB,OADS,EAEhB,4CAFgB,EAGhB,EAHgB,EAIhB,MAJgB,EAKhB,aALgB;AARD,CAAb","sourcesContent":["import invariant from 'tiny-invariant'\r\nimport { ChainId } from '../constants'\r\nimport { validateAndParseAddress } from '../utils'\r\nimport { Currency } from './currency'\r\n\r\n/**\r\n * Represents an ERC20 token with a unique address and some metadata.\r\n */\r\nexport class Token extends Currency {\r\n  public readonly chainId: ChainId\r\n  public readonly address: string\r\n\r\n  public constructor(chainId: ChainId, address: string, decimals: number, symbol?: string, name?: string) {\r\n    super(decimals, symbol, name)\r\n    this.chainId = chainId\r\n    this.address = validateAndParseAddress(address)\r\n  }\r\n\r\n  /**\r\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\r\n   * @param other other token to compare\r\n   */\r\n  public equals(other: Token): boolean {\r\n    // short circuit on reference equality\r\n    if (this === other) {\r\n      return true\r\n    }\r\n    return this.chainId === other.chainId && this.address === other.address\r\n  }\r\n\r\n  /**\r\n   * Returns true if the address of this token sorts before the address of the other token\r\n   * @param other other token to compare\r\n   * @throws if the tokens have the same address\r\n   * @throws if the tokens are on different chains\r\n   */\r\n  public sortsBefore(other: Token): boolean {\r\n    invariant(this.chainId === other.chainId, 'CHAIN_IDS')\r\n    invariant(this.address !== other.address, 'ADDRESSES')\r\n    return this.address.toLowerCase() < other.address.toLowerCase()\r\n  }\r\n}\r\n\r\n/**\r\n * Compares two currencies for equality\r\n */\r\nexport function currencyEquals(currencyA: Currency, currencyB: Currency): boolean {\r\n  if (currencyA instanceof Token && currencyB instanceof Token) {\r\n    return currencyA.equals(currencyB)\r\n  } else if (currencyA instanceof Token) {\r\n    return false\r\n  } else if (currencyB instanceof Token) {\r\n    return false\r\n  } else {\r\n    return currencyA === currencyB\r\n  }\r\n}\r\n\r\nexport const WETH = {\r\n  [ChainId.MAINNET]: new Token(\r\n    ChainId.MAINNET,\r\n    '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',\r\n    18,\r\n    'WBNB',\r\n    'Wrapped BNB'\r\n  ),\r\n  [ChainId.TESTNET]: new Token(\r\n    ChainId.TESTNET,\r\n     '0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd',\r\n     18,\r\n     'WBNB',\r\n     'Wrapped BNB'\r\n    ),\r\n}\r\n"]},"metadata":{},"sourceType":"module"}