{"ast":null,"code":"import invariant from 'tiny-invariant';\nimport { validateAndParseAddress } from './utils';\nimport { ETHER } from './entities';\nimport { TradeType } from './constants';\n/**\r\n * Options for producing the arguments to send call to the router.\r\n */\n\nfunction toHex(currencyAmount) {\n  return `0x${currencyAmount.raw.toString(16)}`;\n}\n\nconst ZERO_HEX = '0x0';\n/**\r\n * Represents the Pancake Router, and has static methods for helping execute trades.\r\n */\n\nexport class Router {\n  /**\r\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\r\n   * @param trade to produce call parameters for\r\n   * @param options options for the call parameters\r\n   */\n  static swapCallParameters(trade, options) {\n    const etherIn = trade.inputAmount.currency === ETHER;\n    const etherOut = trade.outputAmount.currency === ETHER; // the router does not support both ether in and out\n\n    invariant(!(etherIn && etherOut), 'ETHER_IN_OUT');\n    invariant(!('ttl' in options) || options.ttl > 0, 'TTL');\n    const to = validateAndParseAddress(options.recipient);\n    const amountIn = toHex(trade.maximumAmountIn(options.allowedSlippage));\n    const amountOut = toHex(trade.minimumAmountOut(options.allowedSlippage));\n    const path = trade.route.path.map(token => token.address);\n    const deadline = 'ttl' in options ? `0x${(Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16)}` : `0x${options.deadline.toString(16)}`;\n    const useFeeOnTransfer = Boolean(options.feeOnTransfer);\n    let methodName;\n    let args;\n    let value;\n\n    switch (trade.tradeType) {\n      case TradeType.EXACT_INPUT:\n        if (etherIn) {\n          methodName = useFeeOnTransfer ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens'; // (uint amountOutMin, address[] calldata path, address to, uint deadline)\n\n          args = [amountOut, path, to, deadline];\n          value = amountIn;\n        } else if (etherOut) {\n          methodName = useFeeOnTransfer ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH'; // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n\n          args = [amountIn, amountOut, path, to, deadline];\n          value = ZERO_HEX;\n        } else {\n          methodName = useFeeOnTransfer ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens' : 'swapExactTokensForTokens'; // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n\n          args = [amountIn, amountOut, path, to, deadline];\n          value = ZERO_HEX;\n        }\n\n        break;\n\n      case TradeType.EXACT_OUTPUT:\n        invariant(!useFeeOnTransfer, 'EXACT_OUT_FOT');\n\n        if (etherIn) {\n          methodName = 'swapETHForExactTokens'; // (uint amountOut, address[] calldata path, address to, uint deadline)\n\n          args = [amountOut, path, to, deadline];\n          value = amountIn;\n        } else if (etherOut) {\n          methodName = 'swapTokensForExactETH'; // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n\n          args = [amountOut, amountIn, path, to, deadline];\n          value = ZERO_HEX;\n        } else {\n          methodName = 'swapTokensForExactTokens'; // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n\n          args = [amountOut, amountIn, path, to, deadline];\n          value = ZERO_HEX;\n        }\n\n        break;\n    }\n\n    return {\n      methodName,\n      args,\n      value\n    };\n  }\n\n}","map":{"version":3,"sources":["D:/new/1TronicSwap-Build/src/utils/@sdk/router.ts"],"names":["invariant","validateAndParseAddress","ETHER","TradeType","toHex","currencyAmount","raw","toString","ZERO_HEX","Router","swapCallParameters","trade","options","etherIn","inputAmount","currency","etherOut","outputAmount","ttl","to","recipient","amountIn","maximumAmountIn","allowedSlippage","amountOut","minimumAmountOut","path","route","map","token","address","deadline","Math","floor","Date","getTime","useFeeOnTransfer","Boolean","feeOnTransfer","methodName","args","value","tradeType","EXACT_INPUT","EXACT_OUTPUT"],"mappings":"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","sourcesContent":["import invariant from 'tiny-invariant'\r\nimport { validateAndParseAddress } from './utils'\r\nimport { CurrencyAmount, ETHER, Percent, Trade } from './entities'\r\nimport { TradeType } from './constants'\r\n\r\n/**\r\n * Options for producing the arguments to send call to the router.\r\n */\r\nexport interface TradeOptions {\r\n  /**\r\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\r\n   */\r\n  allowedSlippage: Percent\r\n  /**\r\n   * How long the swap is valid until it expires, in seconds.\r\n   * This will be used to produce a `deadline` parameter which is computed from when the swap call parameters\r\n   * are generated.\r\n   */\r\n  ttl: number\r\n  /**\r\n   * The account that should receive the output of the swap.\r\n   */\r\n  recipient: string\r\n\r\n  /**\r\n   * Whether any of the tokens in the path are fee on transfer tokens, which should be handled with special methods\r\n   */\r\n  feeOnTransfer?: boolean\r\n}\r\n\r\nexport interface TradeOptionsDeadline extends Omit<TradeOptions, 'ttl'> {\r\n  /**\r\n   * When the transaction expires.\r\n   * This is an atlernate to specifying the ttl, for when you do not want to use local time.\r\n   */\r\n  deadline: number\r\n}\r\n\r\n/**\r\n * The parameters to use in the call to the Pancake Router to execute a trade.\r\n */\r\nexport interface SwapParameters {\r\n  /**\r\n   * The method to call on the Pancake Router.\r\n   */\r\n  methodName: string\r\n  /**\r\n   * The arguments to pass to the method, all hex encoded.\r\n   */\r\n  args: (string | string[])[]\r\n  /**\r\n   * The amount of wei to send in hex.\r\n   */\r\n  value: string\r\n}\r\n\r\nfunction toHex(currencyAmount: CurrencyAmount) {\r\n  return `0x${currencyAmount.raw.toString(16)}`\r\n}\r\n\r\nconst ZERO_HEX = '0x0'\r\n\r\n/**\r\n * Represents the Pancake Router, and has static methods for helping execute trades.\r\n */\r\nexport abstract class Router {\r\n  /**\r\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\r\n   * @param trade to produce call parameters for\r\n   * @param options options for the call parameters\r\n   */\r\n  public static swapCallParameters(trade: Trade, options: TradeOptions | TradeOptionsDeadline): SwapParameters {\r\n    const etherIn = trade.inputAmount.currency === ETHER\r\n    const etherOut = trade.outputAmount.currency === ETHER\r\n    // the router does not support both ether in and out\r\n    invariant(!(etherIn && etherOut), 'ETHER_IN_OUT')\r\n    invariant(!('ttl' in options) || options.ttl > 0, 'TTL')\r\n\r\n    const to: string = validateAndParseAddress(options.recipient)\r\n    const amountIn: string = toHex(trade.maximumAmountIn(options.allowedSlippage))\r\n    const amountOut: string = toHex(trade.minimumAmountOut(options.allowedSlippage))\r\n    const path: string[] = trade.route.path.map((token) => token.address)\r\n    const deadline =\r\n      'ttl' in options\r\n        ? `0x${(Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16)}`\r\n        : `0x${options.deadline.toString(16)}`\r\n\r\n    const useFeeOnTransfer = Boolean(options.feeOnTransfer)\r\n\r\n    let methodName: string\r\n    let args: (string | string[])[]\r\n    let value: string\r\n    switch (trade.tradeType) {\r\n      case TradeType.EXACT_INPUT:\r\n        if (etherIn) {\r\n          methodName = useFeeOnTransfer ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens'\r\n          // (uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n          args = [amountOut, path, to, deadline]\r\n          value = amountIn\r\n        } else if (etherOut) {\r\n          methodName = useFeeOnTransfer ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH'\r\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n          args = [amountIn, amountOut, path, to, deadline]\r\n          value = ZERO_HEX\r\n        } else {\r\n          methodName = useFeeOnTransfer\r\n            ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens'\r\n            : 'swapExactTokensForTokens'\r\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n          args = [amountIn, amountOut, path, to, deadline]\r\n          value = ZERO_HEX\r\n        }\r\n        break\r\n      case TradeType.EXACT_OUTPUT:\r\n        invariant(!useFeeOnTransfer, 'EXACT_OUT_FOT')\r\n        if (etherIn) {\r\n          methodName = 'swapETHForExactTokens'\r\n          // (uint amountOut, address[] calldata path, address to, uint deadline)\r\n          args = [amountOut, path, to, deadline]\r\n          value = amountIn\r\n        } else if (etherOut) {\r\n          methodName = 'swapTokensForExactETH'\r\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n          args = [amountOut, amountIn, path, to, deadline]\r\n          value = ZERO_HEX\r\n        } else {\r\n          methodName = 'swapTokensForExactTokens'\r\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n          args = [amountOut, amountIn, path, to, deadline]\r\n          value = ZERO_HEX\r\n        }\r\n        break\r\n    }\r\n    return {\r\n      methodName,\r\n      args,\r\n      value,\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}