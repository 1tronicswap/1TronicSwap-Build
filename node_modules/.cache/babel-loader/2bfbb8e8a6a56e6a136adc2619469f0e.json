{"ast":null,"code":"import invariant from 'tiny-invariant';\nimport { Contract } from '@ethersproject/contracts';\nimport { getNetwork } from '@ethersproject/networks';\nimport { getDefaultProvider } from '@ethersproject/providers';\nimport IPancakePair from './IOneTronicPair.json';\nimport { TokenAmount } from './entities/fractions/tokenAmount';\nimport { Pair } from './entities/pair';\nimport ERC20 from './abis/ERC20.json';\nimport { ChainId } from './constants';\nimport { Token } from './entities/token';\nlet TOKEN_DECIMALS_CACHE = {\n  [ChainId.MAINNET]: {\n    '0x97300a4f628701672096460b5469c41a8d3ecb1a': 18 // 1TRC\n\n  }\n};\n/**\r\n * Contains methods for constructing instances of pairs and tokens from on-chain data.\r\n */\n\nexport class Fetcher {\n  /**\r\n   * Cannot be constructed.\r\n   */\n  constructor() {}\n  /**\r\n   * Fetch information for a given token on the given chain, using the given ethers provider.\r\n   * @param chainId chain of the token\r\n   * @param address address of the token on the chain\r\n   * @param provider provider used to fetch the token\r\n   * @param symbol optional symbol of the token\r\n   * @param name optional name of the token\r\n   */\n\n\n  static async fetchTokenData(chainId, address) {\n    var _TOKEN_DECIMALS_CACHE, _TOKEN_DECIMALS_CACHE2;\n\n    let provider = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getDefaultProvider(getNetwork(chainId));\n    let symbol = arguments.length > 3 ? arguments[3] : undefined;\n    let name = arguments.length > 4 ? arguments[4] : undefined;\n    const parsedDecimals = typeof ((_TOKEN_DECIMALS_CACHE = TOKEN_DECIMALS_CACHE) === null || _TOKEN_DECIMALS_CACHE === void 0 ? void 0 : (_TOKEN_DECIMALS_CACHE2 = _TOKEN_DECIMALS_CACHE[chainId]) === null || _TOKEN_DECIMALS_CACHE2 === void 0 ? void 0 : _TOKEN_DECIMALS_CACHE2[address]) === 'number' ? TOKEN_DECIMALS_CACHE[chainId][address] : await new Contract(address, ERC20, provider).decimals().then(decimals => {\n      var _TOKEN_DECIMALS_CACHE3;\n\n      TOKEN_DECIMALS_CACHE = { ...TOKEN_DECIMALS_CACHE,\n        [chainId]: { ...((_TOKEN_DECIMALS_CACHE3 = TOKEN_DECIMALS_CACHE) === null || _TOKEN_DECIMALS_CACHE3 === void 0 ? void 0 : _TOKEN_DECIMALS_CACHE3[chainId]),\n          [address]: decimals\n        }\n      };\n      return decimals;\n    });\n    return new Token(chainId, address, parsedDecimals, symbol, name);\n  }\n  /**\r\n   * Fetches information about a pair and constructs a pair from the given two tokens.\r\n   * @param tokenA first token\r\n   * @param tokenB second token\r\n   * @param provider the provider to use to fetch the data\r\n   */\n\n\n  static async fetchPairData(tokenA, tokenB) {\n    let provider = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getDefaultProvider(getNetwork(tokenA.chainId));\n    invariant(tokenA.chainId === tokenB.chainId, 'CHAIN_ID');\n    const address = Pair.getAddress(tokenA, tokenB);\n    const [reserves0, reserves1] = await new Contract(address, IPancakePair.abi, provider).getReserves();\n    const balances = tokenA.sortsBefore(tokenB) ? [reserves0, reserves1] : [reserves1, reserves0];\n    return new Pair(new TokenAmount(tokenA, balances[0]), new TokenAmount(tokenB, balances[1]));\n  }\n\n}","map":{"version":3,"sources":["D:/new/1TronicSwap-Build/src/utils/@sdk/fetcher.ts"],"names":["invariant","Contract","getNetwork","getDefaultProvider","IPancakePair","TokenAmount","Pair","ERC20","ChainId","Token","TOKEN_DECIMALS_CACHE","MAINNET","Fetcher","constructor","fetchTokenData","chainId","address","provider","symbol","name","parsedDecimals","decimals","then","fetchPairData","tokenA","tokenB","getAddress","reserves0","reserves1","abi","getReserves","balances","sortsBefore"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,gBAAtB;AACA,SAASC,QAAT,QAAyB,0BAAzB;AACA,SAASC,UAAT,QAA2B,yBAA3B;AACA,SAASC,kBAAT,QAAmC,0BAAnC;AACA,OAAOC,YAAP,MAAyB,uBAAzB;AACA,SAASC,WAAT,QAA4B,kCAA5B;AACA,SAASC,IAAT,QAAqB,iBAArB;AACA,OAAOC,KAAP,MAAkB,mBAAlB;AACA,SAASC,OAAT,QAAwB,aAAxB;AACA,SAASC,KAAT,QAAsB,kBAAtB;AAEA,IAAIC,oBAA0E,GAAG;AAC/E,GAACF,OAAO,CAACG,OAAT,GAAmB;AACjB,kDAA8C,EAD7B,CACgC;;AADhC;AAD4D,CAAjF;AAMA;AACA;AACA;;AACA,OAAO,MAAeC,OAAf,CAAuB;AAC5B;AACF;AACA;AACUC,EAAAA,WAAW,GAAG,CAAE;AAExB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACoC,eAAdC,cAAc,CAChCC,OADgC,EAEhCC,OAFgC,EAMhB;AAAA;;AAAA,QAHhBC,QAGgB,uEAHLd,kBAAkB,CAACD,UAAU,CAACa,OAAD,CAAX,CAGb;AAAA,QAFhBG,MAEgB;AAAA,QADhBC,IACgB;AAChB,UAAMC,cAAc,GAClB,iCAAOV,oBAAP,oFAAO,sBAAuBK,OAAvB,CAAP,2DAAO,uBAAkCC,OAAlC,CAAP,MAAsD,QAAtD,GACIN,oBAAoB,CAACK,OAAD,CAApB,CAA8BC,OAA9B,CADJ,GAEI,MAAM,IAAIf,QAAJ,CAAae,OAAb,EAAsBT,KAAtB,EAA6BU,QAA7B,EAAuCI,QAAvC,GAAkDC,IAAlD,CAAwDD,QAAD,IAA8B;AAAA;;AACzFX,MAAAA,oBAAoB,GAAG,EACrB,GAAGA,oBADkB;AAErB,SAACK,OAAD,GAAW,EACT,8BAAGL,oBAAH,2DAAG,uBAAuBK,OAAvB,CAAH,CADS;AAET,WAACC,OAAD,GAAWK;AAFF;AAFU,OAAvB;AAOA,aAAOA,QAAP;AACD,KATK,CAHZ;AAaA,WAAO,IAAIZ,KAAJ,CAAUM,OAAV,EAAmBC,OAAnB,EAA4BI,cAA5B,EAA4CF,MAA5C,EAAoDC,IAApD,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACmC,eAAbI,aAAa,CAC/BC,MAD+B,EAE/BC,MAF+B,EAIhB;AAAA,QADfR,QACe,uEADJd,kBAAkB,CAACD,UAAU,CAACsB,MAAM,CAACT,OAAR,CAAX,CACd;AACff,IAAAA,SAAS,CAACwB,MAAM,CAACT,OAAP,KAAmBU,MAAM,CAACV,OAA3B,EAAoC,UAApC,CAAT;AACA,UAAMC,OAAO,GAAGV,IAAI,CAACoB,UAAL,CAAgBF,MAAhB,EAAwBC,MAAxB,CAAhB;AACA,UAAM,CAACE,SAAD,EAAYC,SAAZ,IAAyB,MAAM,IAAI3B,QAAJ,CAAae,OAAb,EAAsBZ,YAAY,CAACyB,GAAnC,EAAwCZ,QAAxC,EAAkDa,WAAlD,EAArC;AACA,UAAMC,QAAQ,GAAGP,MAAM,CAACQ,WAAP,CAAmBP,MAAnB,IAA6B,CAACE,SAAD,EAAYC,SAAZ,CAA7B,GAAsD,CAACA,SAAD,EAAYD,SAAZ,CAAvE;AACA,WAAO,IAAIrB,IAAJ,CAAS,IAAID,WAAJ,CAAgBmB,MAAhB,EAAwBO,QAAQ,CAAC,CAAD,CAAhC,CAAT,EAA+C,IAAI1B,WAAJ,CAAgBoB,MAAhB,EAAwBM,QAAQ,CAAC,CAAD,CAAhC,CAA/C,CAAP;AACD;;AArD2B","sourcesContent":["import invariant from 'tiny-invariant'\r\nimport { Contract } from '@ethersproject/contracts'\r\nimport { getNetwork } from '@ethersproject/networks'\r\nimport { getDefaultProvider } from '@ethersproject/providers'\r\nimport IPancakePair from './IOneTronicPair.json'\r\nimport { TokenAmount } from './entities/fractions/tokenAmount'\r\nimport { Pair } from './entities/pair'\r\nimport ERC20 from './abis/ERC20.json'\r\nimport { ChainId } from './constants'\r\nimport { Token } from './entities/token'\r\n\r\nlet TOKEN_DECIMALS_CACHE: { [chainId: number]: { [address: string]: number } } = {\r\n  [ChainId.MAINNET]: {\r\n    '0x97300a4f628701672096460b5469c41a8d3ecb1a': 18 // 1TRC\r\n  }\r\n}\r\n\r\n/**\r\n * Contains methods for constructing instances of pairs and tokens from on-chain data.\r\n */\r\nexport abstract class Fetcher {\r\n  /**\r\n   * Cannot be constructed.\r\n   */\r\n  private constructor() {}\r\n\r\n  /**\r\n   * Fetch information for a given token on the given chain, using the given ethers provider.\r\n   * @param chainId chain of the token\r\n   * @param address address of the token on the chain\r\n   * @param provider provider used to fetch the token\r\n   * @param symbol optional symbol of the token\r\n   * @param name optional name of the token\r\n   */\r\n  public static async fetchTokenData(\r\n    chainId: ChainId,\r\n    address: string,\r\n    provider = getDefaultProvider(getNetwork(chainId)),\r\n    symbol?: string,\r\n    name?: string\r\n  ): Promise<Token> {\r\n    const parsedDecimals =\r\n      typeof TOKEN_DECIMALS_CACHE?.[chainId]?.[address] === 'number'\r\n        ? TOKEN_DECIMALS_CACHE[chainId][address]\r\n        : await new Contract(address, ERC20, provider).decimals().then((decimals: number): number => {\r\n            TOKEN_DECIMALS_CACHE = {\r\n              ...TOKEN_DECIMALS_CACHE,\r\n              [chainId]: {\r\n                ...TOKEN_DECIMALS_CACHE?.[chainId],\r\n                [address]: decimals\r\n              }\r\n            }\r\n            return decimals\r\n          })\r\n    return new Token(chainId, address, parsedDecimals, symbol, name)\r\n  }\r\n\r\n  /**\r\n   * Fetches information about a pair and constructs a pair from the given two tokens.\r\n   * @param tokenA first token\r\n   * @param tokenB second token\r\n   * @param provider the provider to use to fetch the data\r\n   */\r\n  public static async fetchPairData(\r\n    tokenA: Token,\r\n    tokenB: Token,\r\n    provider = getDefaultProvider(getNetwork(tokenA.chainId))\r\n  ): Promise<Pair> {\r\n    invariant(tokenA.chainId === tokenB.chainId, 'CHAIN_ID')\r\n    const address = Pair.getAddress(tokenA, tokenB)\r\n    const [reserves0, reserves1] = await new Contract(address, IPancakePair.abi, provider).getReserves()\r\n    const balances = tokenA.sortsBefore(tokenB) ? [reserves0, reserves1] : [reserves1, reserves0]\r\n    return new Pair(new TokenAmount(tokenA, balances[0]), new TokenAmount(tokenB, balances[1]))\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}