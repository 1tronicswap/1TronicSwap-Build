{"ast":null,"code":"import invariant from 'tiny-invariant';\nimport { ONE, TradeType, ZERO } from '../constants';\nimport { sortedInsert } from '../utils';\nimport { ETHER } from './currency';\nimport { CurrencyAmount } from './fractions/currencyAmount';\nimport { Fraction } from './fractions/fraction';\nimport { Percent } from './fractions/percent';\nimport { Price } from './fractions/price';\nimport { TokenAmount } from './fractions/tokenAmount';\nimport { Route } from './route';\nimport { currencyEquals, Token, WETH } from './token';\n/**\r\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\r\n * @param midPrice mid price before the trade\r\n * @param inputAmount the input amount of the trade\r\n * @param outputAmount the output amount of the trade\r\n */\n\nfunction computePriceImpact(midPrice, inputAmount, outputAmount) {\n  const exactQuote = midPrice.raw.multiply(inputAmount.raw); // calculate slippage := (exactQuote - outputAmount) / exactQuote\n\n  const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote);\n  return new Percent(slippage.numerator, slippage.denominator);\n} // minimal interface so the input output comparator may be shared across types\n\n\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\nexport function inputOutputComparator(a, b) {\n  // must have same input and output token for comparison\n  invariant(currencyEquals(a.inputAmount.currency, b.inputAmount.currency), 'INPUT_CURRENCY');\n  invariant(currencyEquals(a.outputAmount.currency, b.outputAmount.currency), 'OUTPUT_CURRENCY');\n\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0;\n    } // trade A requires less input than trade B, so A should come first\n\n\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n} // extension of the input output comparator that also considers other dimensions of the trade in ranking them\n\nexport function tradeComparator(a, b) {\n  const ioComp = inputOutputComparator(a, b);\n\n  if (ioComp !== 0) {\n    return ioComp;\n  } // consider lowest slippage next, since these are less likely to fail\n\n\n  if (a.priceImpact.lessThan(b.priceImpact)) {\n    return -1;\n  } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n    return 1;\n  } // finally consider the number of hops since each hop costs gas\n\n\n  return a.route.path.length - b.route.path.length;\n}\n\n/**\r\n * Given a currency amount and a chain ID, returns the equivalent representation as the token amount.\r\n * In other words, if the currency is ETHER, returns the WETH token amount for the given chain. Otherwise, returns\r\n * the input currency amount.\r\n */\nfunction wrappedAmount(currencyAmount, chainId) {\n  if (currencyAmount instanceof TokenAmount) return currencyAmount;\n  if (currencyAmount.currency === ETHER) return new TokenAmount(WETH[chainId], currencyAmount.raw);\n  invariant(false, 'CURRENCY');\n}\n\nfunction wrappedCurrency(currency, chainId) {\n  if (currency instanceof Token) return currency;\n  if (currency === ETHER) return WETH[chainId];\n  invariant(false, 'CURRENCY');\n}\n/**\r\n * Represents a trade executed against a list of pairs.\r\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\r\n */\n\n\nexport class Trade {\n  /**\r\n   * The route of the trade, i.e. which pairs the trade goes through.\r\n   */\n\n  /**\r\n   * The type of the trade, either exact in or exact out.\r\n   */\n\n  /**\r\n   * The input amount for the trade assuming no slippage.\r\n   */\n\n  /**\r\n   * The output amount for the trade assuming no slippage.\r\n   */\n\n  /**\r\n   * The price expressed in terms of output amount/input amount.\r\n   */\n\n  /**\r\n   * The mid price after the trade executes assuming no slippage.\r\n   */\n\n  /**\r\n   * The percent difference between the mid price before the trade and the trade execution price.\r\n   */\n\n  /**\r\n   * Constructs an exact in trade with the given amount in and route\r\n   * @param route route of the exact in trade\r\n   * @param amountIn the amount being passed in\r\n   */\n  static exactIn(route, amountIn) {\n    return new Trade(route, amountIn, TradeType.EXACT_INPUT);\n  }\n  /**\r\n   * Constructs an exact out trade with the given amount out and route\r\n   * @param route route of the exact out trade\r\n   * @param amountOut the amount returned by the trade\r\n   */\n\n\n  static exactOut(route, amountOut) {\n    return new Trade(route, amountOut, TradeType.EXACT_OUTPUT);\n  }\n\n  constructor(route, amount, tradeType) {\n    this.route = void 0;\n    this.tradeType = void 0;\n    this.inputAmount = void 0;\n    this.outputAmount = void 0;\n    this.executionPrice = void 0;\n    this.nextMidPrice = void 0;\n    this.priceImpact = void 0;\n    const amounts = new Array(route.path.length);\n    const nextPairs = new Array(route.pairs.length);\n\n    if (tradeType === TradeType.EXACT_INPUT) {\n      invariant(currencyEquals(amount.currency, route.input), 'INPUT');\n      amounts[0] = wrappedAmount(amount, route.chainId);\n\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pair = route.pairs[i];\n        const [outputAmount, nextPair] = pair.getOutputAmount(amounts[i]);\n        amounts[i + 1] = outputAmount;\n        nextPairs[i] = nextPair;\n      }\n    } else {\n      invariant(currencyEquals(amount.currency, route.output), 'OUTPUT');\n      amounts[amounts.length - 1] = wrappedAmount(amount, route.chainId);\n\n      for (let i = route.path.length - 1; i > 0; i--) {\n        const pair = route.pairs[i - 1];\n        const [inputAmount, nextPair] = pair.getInputAmount(amounts[i]);\n        amounts[i - 1] = inputAmount;\n        nextPairs[i - 1] = nextPair;\n      }\n    }\n\n    this.route = route;\n    this.tradeType = tradeType;\n    this.inputAmount = tradeType === TradeType.EXACT_INPUT ? amount : route.input === ETHER ? CurrencyAmount.ether(amounts[0].raw) : amounts[0];\n    this.outputAmount = tradeType === TradeType.EXACT_OUTPUT ? amount : route.output === ETHER ? CurrencyAmount.ether(amounts[amounts.length - 1].raw) : amounts[amounts.length - 1];\n    this.executionPrice = new Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.raw, this.outputAmount.raw);\n    this.nextMidPrice = Price.fromRoute(new Route(nextPairs, route.input));\n    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount);\n  }\n  /**\r\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\r\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n   */\n\n\n  minimumAmountOut(slippageTolerance) {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE');\n\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount;\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE).add(slippageTolerance).invert().multiply(this.outputAmount.raw).quotient;\n      return this.outputAmount instanceof TokenAmount ? new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut) : CurrencyAmount.ether(slippageAdjustedAmountOut);\n    }\n  }\n  /**\r\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\r\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n   */\n\n\n  maximumAmountIn(slippageTolerance) {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE');\n\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount;\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient;\n      return this.inputAmount instanceof TokenAmount ? new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn) : CurrencyAmount.ether(slippageAdjustedAmountIn);\n    }\n  }\n  /**\r\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\r\n   * amount to an output token, making at most `maxHops` hops.\r\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\r\n   * the amount in among multiple routes.\r\n   * @param pairs the pairs to consider in finding the best trade\r\n   * @param currencyAmountIn exact amount of input currency to spend\r\n   * @param currencyOut the desired currency out\r\n   * @param maxNumResults maximum number of results to return\r\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\r\n   * @param currentPairs used in recursion; the current list of pairs\r\n   * @param originalAmountIn used in recursion; the original value of the currencyAmountIn parameter\r\n   * @param bestTrades used in recursion; the current list of best trades\r\n   */\n\n\n  static bestTradeExactIn(pairs, currencyAmountIn, currencyOut) {\n    let {\n      maxNumResults = 3,\n      maxHops = 3\n    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let currentPairs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    let originalAmountIn = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : currencyAmountIn;\n    let bestTrades = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n    invariant(pairs.length > 0, 'PAIRS');\n    invariant(maxHops > 0, 'MAX_HOPS');\n    invariant(originalAmountIn === currencyAmountIn || currentPairs.length > 0, 'INVALID_RECURSION');\n    const chainId = currencyAmountIn instanceof TokenAmount ? currencyAmountIn.token.chainId : currencyOut instanceof Token ? currencyOut.chainId : undefined;\n    invariant(chainId !== undefined, 'CHAIN_ID');\n    const amountIn = wrappedAmount(currencyAmountIn, chainId);\n    const tokenOut = wrappedCurrency(currencyOut, chainId);\n\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]; // pair irrelevant\n\n      if (!pair.token0.equals(amountIn.token) && !pair.token1.equals(amountIn.token)) continue;\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue;\n      let amountOut;\n\n      try {\n        [amountOut] = pair.getOutputAmount(amountIn);\n      } catch (error) {\n        // input too low\n        if (error.isInsufficientInputAmountError) {\n          continue;\n        }\n\n        throw error;\n      } // we have arrived at the output token, so this is the final trade of one of the paths\n\n\n      if (amountOut.token.equals(tokenOut)) {\n        sortedInsert(bestTrades, new Trade(new Route([...currentPairs, pair], originalAmountIn.currency, currencyOut), originalAmountIn, TradeType.EXACT_INPUT), maxNumResults, tradeComparator);\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length)); // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n\n        Trade.bestTradeExactIn(pairsExcludingThisPair, amountOut, currencyOut, {\n          maxNumResults,\n          maxHops: maxHops - 1\n        }, [...currentPairs, pair], originalAmountIn, bestTrades);\n      }\n    }\n\n    return bestTrades;\n  }\n  /**\r\n   * similar to the above method but instead targets a fixed output amount\r\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\r\n   * to an output token amount, making at most `maxHops` hops\r\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\r\n   * the amount in among multiple routes.\r\n   * @param pairs the pairs to consider in finding the best trade\r\n   * @param currencyIn the currency to spend\r\n   * @param currencyAmountOut the exact amount of currency out\r\n   * @param maxNumResults maximum number of results to return\r\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\r\n   * @param currentPairs used in recursion; the current list of pairs\r\n   * @param originalAmountOut used in recursion; the original value of the currencyAmountOut parameter\r\n   * @param bestTrades used in recursion; the current list of best trades\r\n   */\n\n\n  static bestTradeExactOut(pairs, currencyIn, currencyAmountOut) {\n    let {\n      maxNumResults = 3,\n      maxHops = 3\n    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let currentPairs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    let originalAmountOut = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : currencyAmountOut;\n    let bestTrades = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n    invariant(pairs.length > 0, 'PAIRS');\n    invariant(maxHops > 0, 'MAX_HOPS');\n    invariant(originalAmountOut === currencyAmountOut || currentPairs.length > 0, 'INVALID_RECURSION');\n    const chainId = currencyAmountOut instanceof TokenAmount ? currencyAmountOut.token.chainId : currencyIn instanceof Token ? currencyIn.chainId : undefined;\n    invariant(chainId !== undefined, 'CHAIN_ID');\n    const amountOut = wrappedAmount(currencyAmountOut, chainId);\n    const tokenIn = wrappedCurrency(currencyIn, chainId);\n\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]; // pair irrelevant\n\n      if (!pair.token0.equals(amountOut.token) && !pair.token1.equals(amountOut.token)) continue;\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue;\n      let amountIn;\n\n      try {\n        [amountIn] = pair.getInputAmount(amountOut);\n      } catch (error) {\n        // not enough liquidity in this pair\n        if (error.isInsufficientReservesError) {\n          continue;\n        }\n\n        throw error;\n      } // we have arrived at the input token, so this is the first trade of one of the paths\n\n\n      if (amountIn.token.equals(tokenIn)) {\n        sortedInsert(bestTrades, new Trade(new Route([pair, ...currentPairs], currencyIn, originalAmountOut.currency), originalAmountOut, TradeType.EXACT_OUTPUT), maxNumResults, tradeComparator);\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length)); // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\n\n        Trade.bestTradeExactOut(pairsExcludingThisPair, currencyIn, amountIn, {\n          maxNumResults,\n          maxHops: maxHops - 1\n        }, [pair, ...currentPairs], originalAmountOut, bestTrades);\n      }\n    }\n\n    return bestTrades;\n  }\n\n}","map":{"version":3,"sources":["D:/new/1TronicSwap-Build/src/utils/@sdk/entities/trade.ts"],"names":["invariant","ONE","TradeType","ZERO","sortedInsert","ETHER","CurrencyAmount","Fraction","Percent","Price","TokenAmount","Route","currencyEquals","Token","WETH","computePriceImpact","midPrice","inputAmount","outputAmount","exactQuote","raw","multiply","slippage","subtract","divide","numerator","denominator","inputOutputComparator","a","b","currency","equalTo","lessThan","tradeComparator","ioComp","priceImpact","greaterThan","route","path","length","wrappedAmount","currencyAmount","chainId","wrappedCurrency","Trade","exactIn","amountIn","EXACT_INPUT","exactOut","amountOut","EXACT_OUTPUT","constructor","amount","tradeType","executionPrice","nextMidPrice","amounts","Array","nextPairs","pairs","input","i","pair","nextPair","getOutputAmount","output","getInputAmount","ether","fromRoute","minimumAmountOut","slippageTolerance","slippageAdjustedAmountOut","add","invert","quotient","token","maximumAmountIn","slippageAdjustedAmountIn","bestTradeExactIn","currencyAmountIn","currencyOut","maxNumResults","maxHops","currentPairs","originalAmountIn","bestTrades","undefined","tokenOut","token0","equals","token1","reserve0","reserve1","error","isInsufficientInputAmountError","pairsExcludingThisPair","slice","concat","bestTradeExactOut","currencyIn","currencyAmountOut","originalAmountOut","tokenIn","isInsufficientReservesError"],"mappings":"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","sourcesContent":["import invariant from 'tiny-invariant'\r\n\r\nimport { ChainId, ONE, TradeType, ZERO } from '../constants'\r\nimport { sortedInsert } from '../utils'\r\nimport { Currency, ETHER } from './currency'\r\nimport { CurrencyAmount } from './fractions/currencyAmount'\r\nimport { Fraction } from './fractions/fraction'\r\nimport { Percent } from './fractions/percent'\r\nimport { Price } from './fractions/price'\r\nimport { TokenAmount } from './fractions/tokenAmount'\r\nimport { Pair } from './pair'\r\nimport { Route } from './route'\r\nimport { currencyEquals, Token, WETH } from './token'\r\n\r\n/**\r\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\r\n * @param midPrice mid price before the trade\r\n * @param inputAmount the input amount of the trade\r\n * @param outputAmount the output amount of the trade\r\n */\r\nfunction computePriceImpact(midPrice: Price, inputAmount: CurrencyAmount, outputAmount: CurrencyAmount): Percent {\r\n  const exactQuote = midPrice.raw.multiply(inputAmount.raw)\r\n  // calculate slippage := (exactQuote - outputAmount) / exactQuote\r\n  const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote)\r\n  return new Percent(slippage.numerator, slippage.denominator)\r\n}\r\n\r\n// minimal interface so the input output comparator may be shared across types\r\ninterface InputOutput {\r\n  readonly inputAmount: CurrencyAmount\r\n  readonly outputAmount: CurrencyAmount\r\n}\r\n\r\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\r\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\r\nexport function inputOutputComparator(a: InputOutput, b: InputOutput): number {\r\n  // must have same input and output token for comparison\r\n  invariant(currencyEquals(a.inputAmount.currency, b.inputAmount.currency), 'INPUT_CURRENCY')\r\n  invariant(currencyEquals(a.outputAmount.currency, b.outputAmount.currency), 'OUTPUT_CURRENCY')\r\n  if (a.outputAmount.equalTo(b.outputAmount)) {\r\n    if (a.inputAmount.equalTo(b.inputAmount)) {\r\n      return 0\r\n    }\r\n    // trade A requires less input than trade B, so A should come first\r\n    if (a.inputAmount.lessThan(b.inputAmount)) {\r\n      return -1\r\n    } else {\r\n      return 1\r\n    }\r\n  } else {\r\n    // tradeA has less output than trade B, so should come second\r\n    if (a.outputAmount.lessThan(b.outputAmount)) {\r\n      return 1\r\n    } else {\r\n      return -1\r\n    }\r\n  }\r\n}\r\n\r\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\r\nexport function tradeComparator(a: Trade, b: Trade) {\r\n  const ioComp = inputOutputComparator(a, b)\r\n  if (ioComp !== 0) {\r\n    return ioComp\r\n  }\r\n\r\n  // consider lowest slippage next, since these are less likely to fail\r\n  if (a.priceImpact.lessThan(b.priceImpact)) {\r\n    return -1\r\n  } else if (a.priceImpact.greaterThan(b.priceImpact)) {\r\n    return 1\r\n  }\r\n\r\n  // finally consider the number of hops since each hop costs gas\r\n  return a.route.path.length - b.route.path.length\r\n}\r\n\r\nexport interface BestTradeOptions {\r\n  // how many results to return\r\n  maxNumResults?: number\r\n  // the maximum number of hops a trade should contain\r\n  maxHops?: number\r\n}\r\n\r\n/**\r\n * Given a currency amount and a chain ID, returns the equivalent representation as the token amount.\r\n * In other words, if the currency is ETHER, returns the WETH token amount for the given chain. Otherwise, returns\r\n * the input currency amount.\r\n */\r\nfunction wrappedAmount(currencyAmount: CurrencyAmount, chainId: ChainId): TokenAmount {\r\n  if (currencyAmount instanceof TokenAmount) return currencyAmount\r\n  if (currencyAmount.currency === ETHER) return new TokenAmount(WETH[chainId], currencyAmount.raw)\r\n  invariant(false, 'CURRENCY')\r\n}\r\n\r\nfunction wrappedCurrency(currency: Currency, chainId: ChainId): Token {\r\n  if (currency instanceof Token) return currency\r\n  if (currency === ETHER) return WETH[chainId]\r\n  invariant(false, 'CURRENCY')\r\n}\r\n\r\n/**\r\n * Represents a trade executed against a list of pairs.\r\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\r\n */\r\nexport class Trade {\r\n  /**\r\n   * The route of the trade, i.e. which pairs the trade goes through.\r\n   */\r\n  public readonly route: Route\r\n  /**\r\n   * The type of the trade, either exact in or exact out.\r\n   */\r\n  public readonly tradeType: TradeType\r\n  /**\r\n   * The input amount for the trade assuming no slippage.\r\n   */\r\n  public readonly inputAmount: CurrencyAmount\r\n  /**\r\n   * The output amount for the trade assuming no slippage.\r\n   */\r\n  public readonly outputAmount: CurrencyAmount\r\n  /**\r\n   * The price expressed in terms of output amount/input amount.\r\n   */\r\n  public readonly executionPrice: Price\r\n  /**\r\n   * The mid price after the trade executes assuming no slippage.\r\n   */\r\n  public readonly nextMidPrice: Price\r\n  /**\r\n   * The percent difference between the mid price before the trade and the trade execution price.\r\n   */\r\n  public readonly priceImpact: Percent\r\n\r\n  /**\r\n   * Constructs an exact in trade with the given amount in and route\r\n   * @param route route of the exact in trade\r\n   * @param amountIn the amount being passed in\r\n   */\r\n  public static exactIn(route: Route, amountIn: CurrencyAmount): Trade {\r\n    return new Trade(route, amountIn, TradeType.EXACT_INPUT)\r\n  }\r\n\r\n  /**\r\n   * Constructs an exact out trade with the given amount out and route\r\n   * @param route route of the exact out trade\r\n   * @param amountOut the amount returned by the trade\r\n   */\r\n  public static exactOut(route: Route, amountOut: CurrencyAmount): Trade {\r\n    return new Trade(route, amountOut, TradeType.EXACT_OUTPUT)\r\n  }\r\n\r\n  public constructor(route: Route, amount: CurrencyAmount, tradeType: TradeType) {\r\n    const amounts: TokenAmount[] = new Array(route.path.length)\r\n    const nextPairs: Pair[] = new Array(route.pairs.length)\r\n    if (tradeType === TradeType.EXACT_INPUT) {\r\n      invariant(currencyEquals(amount.currency, route.input), 'INPUT')\r\n      amounts[0] = wrappedAmount(amount, route.chainId)\r\n      for (let i = 0; i < route.path.length - 1; i++) {\r\n        const pair = route.pairs[i]\r\n        const [outputAmount, nextPair] = pair.getOutputAmount(amounts[i])\r\n        amounts[i + 1] = outputAmount\r\n        nextPairs[i] = nextPair\r\n      }\r\n    } else {\r\n      invariant(currencyEquals(amount.currency, route.output), 'OUTPUT')\r\n      amounts[amounts.length - 1] = wrappedAmount(amount, route.chainId)\r\n      for (let i = route.path.length - 1; i > 0; i--) {\r\n        const pair = route.pairs[i - 1]\r\n        const [inputAmount, nextPair] = pair.getInputAmount(amounts[i])\r\n        amounts[i - 1] = inputAmount\r\n        nextPairs[i - 1] = nextPair\r\n      }\r\n    }\r\n\r\n    this.route = route\r\n    this.tradeType = tradeType\r\n    this.inputAmount =\r\n      tradeType === TradeType.EXACT_INPUT\r\n        ? amount\r\n        : route.input === ETHER\r\n        ? CurrencyAmount.ether(amounts[0].raw)\r\n        : amounts[0]\r\n    this.outputAmount =\r\n      tradeType === TradeType.EXACT_OUTPUT\r\n        ? amount\r\n        : route.output === ETHER\r\n        ? CurrencyAmount.ether(amounts[amounts.length - 1].raw)\r\n        : amounts[amounts.length - 1]\r\n    this.executionPrice = new Price(\r\n      this.inputAmount.currency,\r\n      this.outputAmount.currency,\r\n      this.inputAmount.raw,\r\n      this.outputAmount.raw\r\n    )\r\n    this.nextMidPrice = Price.fromRoute(new Route(nextPairs, route.input))\r\n    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount)\r\n  }\r\n\r\n  /**\r\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\r\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n   */\r\n  public minimumAmountOut(slippageTolerance: Percent): CurrencyAmount {\r\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\r\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\r\n      return this.outputAmount\r\n    } else {\r\n      const slippageAdjustedAmountOut = new Fraction(ONE)\r\n        .add(slippageTolerance)\r\n        .invert()\r\n        .multiply(this.outputAmount.raw).quotient\r\n      return this.outputAmount instanceof TokenAmount\r\n        ? new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut)\r\n        : CurrencyAmount.ether(slippageAdjustedAmountOut)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\r\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n   */\r\n  public maximumAmountIn(slippageTolerance: Percent): CurrencyAmount {\r\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\r\n    if (this.tradeType === TradeType.EXACT_INPUT) {\r\n      return this.inputAmount\r\n    } else {\r\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient\r\n      return this.inputAmount instanceof TokenAmount\r\n        ? new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn)\r\n        : CurrencyAmount.ether(slippageAdjustedAmountIn)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\r\n   * amount to an output token, making at most `maxHops` hops.\r\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\r\n   * the amount in among multiple routes.\r\n   * @param pairs the pairs to consider in finding the best trade\r\n   * @param currencyAmountIn exact amount of input currency to spend\r\n   * @param currencyOut the desired currency out\r\n   * @param maxNumResults maximum number of results to return\r\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\r\n   * @param currentPairs used in recursion; the current list of pairs\r\n   * @param originalAmountIn used in recursion; the original value of the currencyAmountIn parameter\r\n   * @param bestTrades used in recursion; the current list of best trades\r\n   */\r\n  public static bestTradeExactIn(\r\n    pairs: Pair[],\r\n    currencyAmountIn: CurrencyAmount,\r\n    currencyOut: Currency,\r\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\r\n    // used in recursion.\r\n    currentPairs: Pair[] = [],\r\n    originalAmountIn: CurrencyAmount = currencyAmountIn,\r\n    bestTrades: Trade[] = []\r\n  ): Trade[] {\r\n    invariant(pairs.length > 0, 'PAIRS')\r\n    invariant(maxHops > 0, 'MAX_HOPS')\r\n    invariant(originalAmountIn === currencyAmountIn || currentPairs.length > 0, 'INVALID_RECURSION')\r\n    const chainId: ChainId | undefined =\r\n      currencyAmountIn instanceof TokenAmount\r\n        ? currencyAmountIn.token.chainId\r\n        : currencyOut instanceof Token\r\n        ? currencyOut.chainId\r\n        : undefined\r\n    invariant(chainId !== undefined, 'CHAIN_ID')\r\n\r\n    const amountIn = wrappedAmount(currencyAmountIn, chainId)\r\n    const tokenOut = wrappedCurrency(currencyOut, chainId)\r\n    for (let i = 0; i < pairs.length; i++) {\r\n      const pair = pairs[i]\r\n      // pair irrelevant\r\n      if (!pair.token0.equals(amountIn.token) && !pair.token1.equals(amountIn.token)) continue\r\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\r\n\r\n      let amountOut: TokenAmount\r\n      try {\r\n        [amountOut] = pair.getOutputAmount(amountIn)\r\n      } catch (error) {\r\n        // input too low\r\n        if (error.isInsufficientInputAmountError) {\r\n          continue\r\n        }\r\n        throw error\r\n      }\r\n      // we have arrived at the output token, so this is the final trade of one of the paths\r\n      if (amountOut.token.equals(tokenOut)) {\r\n        sortedInsert(\r\n          bestTrades,\r\n          new Trade(\r\n            new Route([...currentPairs, pair], originalAmountIn.currency, currencyOut),\r\n            originalAmountIn,\r\n            TradeType.EXACT_INPUT\r\n          ),\r\n          maxNumResults,\r\n          tradeComparator\r\n        )\r\n      } else if (maxHops > 1 && pairs.length > 1) {\r\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\r\n\r\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\r\n        Trade.bestTradeExactIn(\r\n          pairsExcludingThisPair,\r\n          amountOut,\r\n          currencyOut,\r\n          {\r\n            maxNumResults,\r\n            maxHops: maxHops - 1\r\n          },\r\n          [...currentPairs, pair],\r\n          originalAmountIn,\r\n          bestTrades\r\n        )\r\n      }\r\n    }\r\n\r\n    return bestTrades\r\n  }\r\n\r\n  /**\r\n   * similar to the above method but instead targets a fixed output amount\r\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\r\n   * to an output token amount, making at most `maxHops` hops\r\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\r\n   * the amount in among multiple routes.\r\n   * @param pairs the pairs to consider in finding the best trade\r\n   * @param currencyIn the currency to spend\r\n   * @param currencyAmountOut the exact amount of currency out\r\n   * @param maxNumResults maximum number of results to return\r\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\r\n   * @param currentPairs used in recursion; the current list of pairs\r\n   * @param originalAmountOut used in recursion; the original value of the currencyAmountOut parameter\r\n   * @param bestTrades used in recursion; the current list of best trades\r\n   */\r\n  public static bestTradeExactOut(\r\n    pairs: Pair[],\r\n    currencyIn: Currency,\r\n    currencyAmountOut: CurrencyAmount,\r\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\r\n    // used in recursion.\r\n    currentPairs: Pair[] = [],\r\n    originalAmountOut: CurrencyAmount = currencyAmountOut,\r\n    bestTrades: Trade[] = []\r\n  ): Trade[] {\r\n    invariant(pairs.length > 0, 'PAIRS')\r\n    invariant(maxHops > 0, 'MAX_HOPS')\r\n    invariant(originalAmountOut === currencyAmountOut || currentPairs.length > 0, 'INVALID_RECURSION')\r\n    const chainId: ChainId | undefined =\r\n      currencyAmountOut instanceof TokenAmount\r\n        ? currencyAmountOut.token.chainId\r\n        : currencyIn instanceof Token\r\n        ? currencyIn.chainId\r\n        : undefined\r\n    invariant(chainId !== undefined, 'CHAIN_ID')\r\n\r\n    const amountOut = wrappedAmount(currencyAmountOut, chainId)\r\n    const tokenIn = wrappedCurrency(currencyIn, chainId)\r\n    for (let i = 0; i < pairs.length; i++) {\r\n      const pair = pairs[i]\r\n      // pair irrelevant\r\n      if (!pair.token0.equals(amountOut.token) && !pair.token1.equals(amountOut.token)) continue\r\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\r\n\r\n      let amountIn: TokenAmount\r\n      try {\r\n        [amountIn] = pair.getInputAmount(amountOut)\r\n      } catch (error) {\r\n        // not enough liquidity in this pair\r\n        if (error.isInsufficientReservesError) {\r\n          continue\r\n        }\r\n        throw error\r\n      }\r\n      // we have arrived at the input token, so this is the first trade of one of the paths\r\n      if (amountIn.token.equals(tokenIn)) {\r\n        sortedInsert(\r\n          bestTrades,\r\n          new Trade(\r\n            new Route([pair, ...currentPairs], currencyIn, originalAmountOut.currency),\r\n            originalAmountOut,\r\n            TradeType.EXACT_OUTPUT\r\n          ),\r\n          maxNumResults,\r\n          tradeComparator\r\n        )\r\n      } else if (maxHops > 1 && pairs.length > 1) {\r\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\r\n\r\n        // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\r\n        Trade.bestTradeExactOut(\r\n          pairsExcludingThisPair,\r\n          currencyIn,\r\n          amountIn,\r\n          {\r\n            maxNumResults,\r\n            maxHops: maxHops - 1\r\n          },\r\n          [pair, ...currentPairs],\r\n          originalAmountOut,\r\n          bestTrades\r\n        )\r\n      }\r\n    }\r\n\r\n    return bestTrades\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}