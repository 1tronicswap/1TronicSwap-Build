{"ast":null,"code":"import { request, gql } from 'graphql-request';\nimport { GRAPH_API_LOTTERY } from 'config/constants/endpoints';\nimport { getRoundIdsArray, fetchMultipleLotteries, hasRoundBeenClaimed, processRawTicketsResponse } from './helpers';\nimport { fetchUserTicketsForMultipleRounds } from './fetchUnclaimedUserRewards';\n\nconst applyNodeDataToUserGraphResponse = (nodeData, graphData, ticketData) => {\n  //   If no graph rounds response - return node data\n  if (graphData.length === 0) {\n    return nodeData.map(nodeRound => {\n      const ticketDataForRound = ticketData.find(roundTickets => roundTickets.roundId === nodeRound.lotteryId);\n      return {\n        endTime: nodeRound.endTime,\n        status: nodeRound.status,\n        lotteryId: nodeRound.lotteryId.toString(),\n        claimed: hasRoundBeenClaimed(ticketDataForRound.userTickets),\n        totalTickets: `${ticketDataForRound.userTickets.length.toString()}`\n      };\n    });\n  } //   Else if there is a graph response - merge with node data where node data is more accurate\n\n\n  const mergedResponse = graphData.map((graphRound, index) => {\n    const nodeRound = nodeData[index]; // if there is node data for this index, overwrite graph data. Otherwise - return graph data.\n\n    if (nodeRound) {\n      const ticketDataForRound = ticketData.find(roundTickets => roundTickets.roundId === nodeRound.lotteryId); // if isLoading === true, there has been a node error - return graphRound\n\n      if (!nodeRound.isLoading) {\n        return {\n          endTime: nodeRound.endTime,\n          status: nodeRound.status,\n          lotteryId: nodeRound.lotteryId.toString(),\n          claimed: hasRoundBeenClaimed(ticketDataForRound.userTickets),\n          totalTickets: graphRound.totalTickets\n        };\n      }\n\n      return graphRound;\n    }\n\n    return graphRound;\n  });\n  return mergedResponse;\n};\n\nconst getGraphLotteryUser = async account => {\n  let user;\n  const blankUser = {\n    account,\n    totalCake: '',\n    totalTickets: '',\n    rounds: []\n  };\n\n  try {\n    const response = await request(GRAPH_API_LOTTERY, gql`\n        query getUserLotteries($account: ID!) {\n          user(id: $account) {\n            id\n            totalTickets\n            totalCake\n            rounds(first: 100, orderDirection: desc, orderBy: block) {\n              id\n              lottery {\n                id\n                endTime\n                status\n              }\n              claimed\n              totalTickets\n            }\n          }\n        }\n      `, {\n      account: account.toLowerCase()\n    });\n    const userRes = response.user; // If no user returned - return blank user\n\n    if (!userRes) {\n      user = blankUser;\n    } else {\n      user = {\n        account: userRes.id,\n        totalCake: userRes.totalCake,\n        totalTickets: userRes.totalTickets,\n        rounds: userRes.rounds.map(round => {\n          var _round$lottery, _round$lottery2, _round$lottery3;\n\n          return {\n            lotteryId: round === null || round === void 0 ? void 0 : (_round$lottery = round.lottery) === null || _round$lottery === void 0 ? void 0 : _round$lottery.id,\n            endTime: round === null || round === void 0 ? void 0 : (_round$lottery2 = round.lottery) === null || _round$lottery2 === void 0 ? void 0 : _round$lottery2.endTime,\n            claimed: round === null || round === void 0 ? void 0 : round.claimed,\n            totalTickets: round === null || round === void 0 ? void 0 : round.totalTickets,\n            status: round === null || round === void 0 ? void 0 : (_round$lottery3 = round.lottery) === null || _round$lottery3 === void 0 ? void 0 : _round$lottery3.status\n          };\n        })\n      };\n    }\n  } catch (error) {\n    console.error(error);\n    user = blankUser;\n  }\n\n  return user;\n};\n\nconst getUserLotteryData = async (account, currentLotteryId) => {\n  const idsForTicketsNodeCall = getRoundIdsArray(currentLotteryId);\n  const ticketsToRequestPerRound = '5000';\n  const blindRoundData = idsForTicketsNodeCall.map(roundId => {\n    return {\n      totalTickets: ticketsToRequestPerRound,\n      lotteryId: roundId.toString()\n    };\n  });\n  const rawUserTicketNodeData = await fetchUserTicketsForMultipleRounds(blindRoundData, account);\n  const roundDataAndUserTickets = rawUserTicketNodeData.map((rawRoundTicketData, index) => {\n    return {\n      roundId: idsForTicketsNodeCall[index],\n      userTickets: processRawTicketsResponse(rawRoundTicketData)\n    };\n  });\n  const roundsWithUserParticipation = roundDataAndUserTickets.filter(round => round.userTickets.length > 0);\n  const idsForLotteriesNodeCall = roundsWithUserParticipation.map(round => round.roundId);\n  const lotteriesNodeData = await fetchMultipleLotteries(idsForLotteriesNodeCall);\n  const graphResponse = await getGraphLotteryUser(account);\n  const mergedRoundData = applyNodeDataToUserGraphResponse(lotteriesNodeData, graphResponse.rounds, roundsWithUserParticipation);\n  const graphResponseWithNodeRounds = { ...graphResponse,\n    rounds: mergedRoundData\n  };\n  return graphResponseWithNodeRounds;\n};\n\nexport default getUserLotteryData;","map":{"version":3,"sources":["D:/new/1TronicSwap-Build/src/state/lottery/getUserLotteryData.ts"],"names":["request","gql","GRAPH_API_LOTTERY","getRoundIdsArray","fetchMultipleLotteries","hasRoundBeenClaimed","processRawTicketsResponse","fetchUserTicketsForMultipleRounds","applyNodeDataToUserGraphResponse","nodeData","graphData","ticketData","length","map","nodeRound","ticketDataForRound","find","roundTickets","roundId","lotteryId","endTime","status","toString","claimed","userTickets","totalTickets","mergedResponse","graphRound","index","isLoading","getGraphLotteryUser","account","user","blankUser","totalCake","rounds","response","toLowerCase","userRes","id","round","lottery","error","console","getUserLotteryData","currentLotteryId","idsForTicketsNodeCall","ticketsToRequestPerRound","blindRoundData","rawUserTicketNodeData","roundDataAndUserTickets","rawRoundTicketData","roundsWithUserParticipation","filter","idsForLotteriesNodeCall","lotteriesNodeData","graphResponse","mergedRoundData","graphResponseWithNodeRounds"],"mappings":"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","sourcesContent":["import { request, gql } from 'graphql-request'\r\nimport { GRAPH_API_LOTTERY } from 'config/constants/endpoints'\r\nimport { LotteryTicket } from 'config/constants/types'\r\nimport { LotteryUserGraphEntity, LotteryResponse, UserRound } from 'state/types'\r\nimport { getRoundIdsArray, fetchMultipleLotteries, hasRoundBeenClaimed, processRawTicketsResponse } from './helpers'\r\nimport { fetchUserTicketsForMultipleRounds } from './fetchUnclaimedUserRewards'\r\n\r\nconst applyNodeDataToUserGraphResponse = (\r\n  nodeData: LotteryResponse[],\r\n  graphData: UserRound[],\r\n  ticketData: { roundId: string; userTickets: LotteryTicket[] }[],\r\n): UserRound[] => {\r\n  //   If no graph rounds response - return node data\r\n  if (graphData.length === 0) {\r\n    return nodeData.map((nodeRound) => {\r\n      const ticketDataForRound = ticketData.find((roundTickets) => roundTickets.roundId === nodeRound.lotteryId)\r\n      return {\r\n        endTime: nodeRound.endTime,\r\n        status: nodeRound.status,\r\n        lotteryId: nodeRound.lotteryId.toString(),\r\n        claimed: hasRoundBeenClaimed(ticketDataForRound.userTickets),\r\n        totalTickets: `${ticketDataForRound.userTickets.length.toString()}`,\r\n      }\r\n    })\r\n  }\r\n\r\n  //   Else if there is a graph response - merge with node data where node data is more accurate\r\n  const mergedResponse = graphData.map((graphRound, index) => {\r\n    const nodeRound = nodeData[index]\r\n    // if there is node data for this index, overwrite graph data. Otherwise - return graph data.\r\n    if (nodeRound) {\r\n      const ticketDataForRound = ticketData.find((roundTickets) => roundTickets.roundId === nodeRound.lotteryId)\r\n      // if isLoading === true, there has been a node error - return graphRound\r\n      if (!nodeRound.isLoading) {\r\n        return {\r\n          endTime: nodeRound.endTime,\r\n          status: nodeRound.status,\r\n          lotteryId: nodeRound.lotteryId.toString(),\r\n          claimed: hasRoundBeenClaimed(ticketDataForRound.userTickets),\r\n          totalTickets: graphRound.totalTickets,\r\n        }\r\n      }\r\n      return graphRound\r\n    }\r\n    return graphRound\r\n  })\r\n  return mergedResponse\r\n}\r\n\r\nconst getGraphLotteryUser = async (account: string): Promise<LotteryUserGraphEntity> => {\r\n  let user\r\n  const blankUser = {\r\n    account,\r\n    totalCake: '',\r\n    totalTickets: '',\r\n    rounds: [],\r\n  }\r\n\r\n  try {\r\n    const response = await request(\r\n      GRAPH_API_LOTTERY,\r\n      gql`\r\n        query getUserLotteries($account: ID!) {\r\n          user(id: $account) {\r\n            id\r\n            totalTickets\r\n            totalCake\r\n            rounds(first: 100, orderDirection: desc, orderBy: block) {\r\n              id\r\n              lottery {\r\n                id\r\n                endTime\r\n                status\r\n              }\r\n              claimed\r\n              totalTickets\r\n            }\r\n          }\r\n        }\r\n      `,\r\n      { account: account.toLowerCase() },\r\n    )\r\n    const userRes = response.user\r\n\r\n    // If no user returned - return blank user\r\n    if (!userRes) {\r\n      user = blankUser\r\n    } else {\r\n      user = {\r\n        account: userRes.id,\r\n        totalCake: userRes.totalCake,\r\n        totalTickets: userRes.totalTickets,\r\n        rounds: userRes.rounds.map((round) => {\r\n          return {\r\n            lotteryId: round?.lottery?.id,\r\n            endTime: round?.lottery?.endTime,\r\n            claimed: round?.claimed,\r\n            totalTickets: round?.totalTickets,\r\n            status: round?.lottery?.status,\r\n          }\r\n        }),\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error(error)\r\n    user = blankUser\r\n  }\r\n\r\n  return user\r\n}\r\n\r\nconst getUserLotteryData = async (account: string, currentLotteryId: string): Promise<LotteryUserGraphEntity> => {\r\n  const idsForTicketsNodeCall = getRoundIdsArray(currentLotteryId)\r\n  const ticketsToRequestPerRound = '5000'\r\n  const blindRoundData = idsForTicketsNodeCall.map((roundId) => {\r\n    return {\r\n      totalTickets: ticketsToRequestPerRound,\r\n      lotteryId: roundId.toString(),\r\n    }\r\n  })\r\n\r\n  const rawUserTicketNodeData = await fetchUserTicketsForMultipleRounds(blindRoundData, account)\r\n  const roundDataAndUserTickets = rawUserTicketNodeData.map((rawRoundTicketData, index) => {\r\n    return {\r\n      roundId: idsForTicketsNodeCall[index],\r\n      userTickets: processRawTicketsResponse(rawRoundTicketData),\r\n    }\r\n  })\r\n  const roundsWithUserParticipation = roundDataAndUserTickets.filter((round) => round.userTickets.length > 0)\r\n  const idsForLotteriesNodeCall = roundsWithUserParticipation.map((round) => round.roundId)\r\n\r\n  const lotteriesNodeData = await fetchMultipleLotteries(idsForLotteriesNodeCall)\r\n  const graphResponse = await getGraphLotteryUser(account)\r\n  const mergedRoundData = applyNodeDataToUserGraphResponse(\r\n    lotteriesNodeData,\r\n    graphResponse.rounds,\r\n    roundsWithUserParticipation,\r\n  )\r\n  const graphResponseWithNodeRounds = { ...graphResponse, rounds: mergedRoundData }\r\n  return graphResponseWithNodeRounds\r\n}\r\n\r\nexport default getUserLotteryData\r\n"]},"metadata":{},"sourceType":"module"}