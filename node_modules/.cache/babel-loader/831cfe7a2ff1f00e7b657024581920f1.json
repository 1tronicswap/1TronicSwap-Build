{"ast":null,"code":"import invariant from 'tiny-invariant';\nimport JSBI from 'jsbi';\nimport _Big from 'big.js';\nimport toFormat from 'toformat';\nimport { currencyEquals } from '../token';\nimport { ETHER } from '../currency';\nimport { Rounding, TEN, SolidityType } from '../../constants';\nimport { parseBigintIsh, validateSolidityTypeInstance } from '../../utils';\nimport { Fraction } from './fraction';\nconst Big = toFormat(_Big);\nexport class CurrencyAmount extends Fraction {\n  /**\r\n   * Helper that calls the constructor with the ETHER currency\r\n   * @param amount ether amount in wei\r\n   */\n  static ether(amount) {\n    return new CurrencyAmount(ETHER, amount);\n  } // amount _must_ be raw, i.e. in the native representation\n\n\n  constructor(currency, amount) {\n    const parsedAmount = parseBigintIsh(amount);\n    validateSolidityTypeInstance(parsedAmount, SolidityType.uint256);\n    super(parsedAmount, JSBI.exponentiate(TEN, JSBI.BigInt(currency.decimals)));\n    this.currency = void 0;\n    this.currency = currency;\n  }\n\n  get raw() {\n    return this.numerator;\n  }\n\n  add(other) {\n    invariant(currencyEquals(this.currency, other.currency), 'TOKEN');\n    return new CurrencyAmount(this.currency, JSBI.add(this.raw, other.raw));\n  }\n\n  subtract(other) {\n    invariant(currencyEquals(this.currency, other.currency), 'TOKEN');\n    return new CurrencyAmount(this.currency, JSBI.subtract(this.raw, other.raw));\n  }\n\n  toSignificant() {\n    let significantDigits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 6;\n    let format = arguments.length > 1 ? arguments[1] : undefined;\n    let rounding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Rounding.ROUND_DOWN;\n    return super.toSignificant(significantDigits, format, rounding);\n  }\n\n  toFixed() {\n    let decimalPlaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currency.decimals;\n    let format = arguments.length > 1 ? arguments[1] : undefined;\n    let rounding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Rounding.ROUND_DOWN;\n    invariant(decimalPlaces <= this.currency.decimals, 'DECIMALS');\n    return super.toFixed(decimalPlaces, format, rounding);\n  }\n\n  toExact() {\n    let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      groupSeparator: ''\n    };\n    Big.DP = this.currency.decimals;\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(format);\n  }\n\n}","map":{"version":3,"sources":["D:/new/1TronicSwap-Build/src/utils/@sdk/entities/fractions/currencyAmount.ts"],"names":["invariant","JSBI","_Big","toFormat","currencyEquals","ETHER","Rounding","TEN","SolidityType","parseBigintIsh","validateSolidityTypeInstance","Fraction","Big","CurrencyAmount","ether","amount","constructor","currency","parsedAmount","uint256","exponentiate","BigInt","decimals","raw","numerator","add","other","subtract","toSignificant","significantDigits","format","rounding","ROUND_DOWN","toFixed","decimalPlaces","toExact","groupSeparator","DP","toString","div","denominator"],"mappings":"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","sourcesContent":["import invariant from 'tiny-invariant'\r\nimport JSBI from 'jsbi'\r\nimport _Big from 'big.js'\r\nimport toFormat from 'toformat'\r\nimport { currencyEquals } from '../token'\r\nimport { Currency, ETHER } from '../currency'\r\nimport { BigintIsh, Rounding, TEN, SolidityType } from '../../constants'\r\nimport { parseBigintIsh, validateSolidityTypeInstance } from '../../utils'\r\nimport { Fraction } from './fraction'\r\n\r\nconst Big = toFormat(_Big)\r\n\r\nexport class CurrencyAmount extends Fraction {\r\n  public readonly currency: Currency\r\n\r\n  /**\r\n   * Helper that calls the constructor with the ETHER currency\r\n   * @param amount ether amount in wei\r\n   */\r\n  public static ether(amount: BigintIsh): CurrencyAmount {\r\n    return new CurrencyAmount(ETHER, amount)\r\n  }\r\n\r\n  // amount _must_ be raw, i.e. in the native representation\r\n  protected constructor(currency: Currency, amount: BigintIsh) {\r\n    const parsedAmount = parseBigintIsh(amount)\r\n    validateSolidityTypeInstance(parsedAmount, SolidityType.uint256)\r\n\r\n    super(parsedAmount, JSBI.exponentiate(TEN, JSBI.BigInt(currency.decimals)))\r\n    this.currency = currency\r\n  }\r\n\r\n  public get raw(): JSBI {\r\n    return this.numerator\r\n  }\r\n\r\n  public add(other: CurrencyAmount): CurrencyAmount {\r\n    invariant(currencyEquals(this.currency, other.currency), 'TOKEN')\r\n    return new CurrencyAmount(this.currency, JSBI.add(this.raw, other.raw))\r\n  }\r\n\r\n  public subtract(other: CurrencyAmount): CurrencyAmount {\r\n    invariant(currencyEquals(this.currency, other.currency), 'TOKEN')\r\n    return new CurrencyAmount(this.currency, JSBI.subtract(this.raw, other.raw))\r\n  }\r\n\r\n  public toSignificant(\r\n    significantDigits: number = 6,\r\n    format?: object,\r\n    rounding: Rounding = Rounding.ROUND_DOWN\r\n  ): string {\r\n    return super.toSignificant(significantDigits, format, rounding)\r\n  }\r\n\r\n  public toFixed(\r\n    decimalPlaces: number = this.currency.decimals,\r\n    format?: object,\r\n    rounding: Rounding = Rounding.ROUND_DOWN\r\n  ): string {\r\n    invariant(decimalPlaces <= this.currency.decimals, 'DECIMALS')\r\n    return super.toFixed(decimalPlaces, format, rounding)\r\n  }\r\n\r\n  public toExact(format: object = { groupSeparator: '' }): string {\r\n    Big.DP = this.currency.decimals\r\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(format)\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}