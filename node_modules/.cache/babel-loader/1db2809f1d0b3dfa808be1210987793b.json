{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useMemo, useReducer, useEffect, useCallback } from \"react\";\nimport noop from \"lodash/noop\";\nimport { byTextAscending, byTextDescending } from \"./utils\";\n\nconst sortByColumn = (data, sortColumn, columns) => {\n  let isAscending = null;\n  let sortedRows = [...data];\n  columns.forEach(column => {\n    // if the row was found\n    if (sortColumn === column.name) {\n      isAscending = column.sorted.asc;\n\n      if (column.sort) {\n        sortedRows = isAscending ? data.sort(column.sort) : data.sort(column.sort).reverse(); // default to sort by string\n      } else {\n        sortedRows = isAscending ? data.sort(byTextAscending(object => object.original[sortColumn])) : data.sort(byTextDescending(object => object.original[sortColumn]));\n      }\n    }\n  });\n  return sortedRows;\n};\n\nconst getPaginatedData = (rows, perPage, page) => {\n  const start = (page - 1) * perPage;\n  const end = start + perPage;\n  return rows.slice(start, end);\n};\n\nconst getColumnsByName = columns => {\n  const columnsByName = {};\n  columns.forEach(column => {\n    const col = {\n      name: column.name,\n      label: column.label\n    };\n\n    if (column.render) {\n      col.render = column.render;\n    }\n\n    col.hidden = column.hidden;\n    columnsByName[column.name] = col;\n  });\n  return columnsByName;\n};\n\nconst createReducer = () => (state, action) => {\n  let rows = [];\n  let nextPage = 0;\n  let prevPage = 0;\n  let isAscending = null;\n  let sortedRows = [];\n  let columnCopy = [];\n  let filteredRows = [];\n  let selectedRowsById = {};\n  let stateCopy = { ...state\n  };\n  const rowIds = {};\n\n  switch (action.type) {\n    case \"SET_ROWS\":\n      rows = [...action.data]; // preserve sorting if a sort is already enabled when data changes\n\n      if (state.sortColumn) {\n        rows = sortByColumn(action.data, state.sortColumn, state.columns);\n      }\n\n      if (state.paginationEnabled === true) {\n        rows = getPaginatedData(rows, state.pagination.perPage, state.pagination.page);\n      }\n\n      if (state.paginationEnabled === true) {\n        rows = getPaginatedData(rows, state.pagination.perPage, state.pagination.page);\n      }\n\n      columnCopy = state.columns.map(column => {\n        if (state.sortColumn === column.name) {\n          return { ...column,\n            sorted: {\n              on: true,\n              asc: column.sorted.asc\n            }\n          };\n        }\n\n        return column;\n      });\n      return { ...state,\n        rows,\n        originalRows: action.data,\n        columns: columnCopy\n      };\n\n    case \"NEXT_PAGE\":\n      nextPage = state.pagination.page + 1;\n      return { ...state,\n        rows: getPaginatedData(state.originalRows, state.pagination.perPage, nextPage),\n        pagination: { ...state.pagination,\n          page: nextPage,\n          canNext: nextPage * state.pagination.perPage < state.originalRows.length,\n          canPrev: nextPage !== 1\n        }\n      };\n\n    case \"PREV_PAGE\":\n      prevPage = state.pagination.page === 1 ? 1 : state.pagination.page - 1;\n      return { ...state,\n        rows: getPaginatedData(state.originalRows, state.pagination.perPage, prevPage),\n        pagination: { ...state.pagination,\n          page: prevPage,\n          canNext: prevPage * state.pagination.perPage < state.originalRows.length,\n          canPrev: prevPage !== 1\n        }\n      };\n\n    case \"TOGGLE_SORT\":\n      if (!(action.columnName in state.columnsByName)) {\n        throw new Error(`Invalid column, ${action.columnName} not found`);\n      } // loop through all columns and set the sort parameter to off unless\n      // it's the specified column (only one column at a time for )\n\n\n      columnCopy = state.columns.map(column => {\n        // if the row was found\n        if (action.columnName === column.name) {\n          if (action.isAscOverride !== undefined) {\n            // force the sort order\n            isAscending = action.isAscOverride;\n          } else {\n            // if it's undefined, start by setting to ascending, otherwise toggle\n            isAscending = column.sorted.asc === undefined ? true : !column.sorted.asc;\n          }\n\n          if (column.sort) {\n            sortedRows = isAscending ? state.rows.sort(column.sort) : state.rows.sort(column.sort).reverse(); // default to sort by string\n          } else {\n            sortedRows = isAscending ? state.rows.sort(byTextAscending(object => object.original[action.columnName])) : state.rows.sort(byTextDescending(object => object.original[action.columnName]));\n          }\n\n          return { ...column,\n            sorted: {\n              on: true,\n              asc: isAscending\n            }\n          };\n        } // set sorting to false for all other columns\n\n\n        return { ...column,\n          sorted: {\n            on: false,\n            asc: false\n          }\n        };\n      });\n      return { ...state,\n        columns: columnCopy,\n        rows: sortedRows,\n        sortColumn: action.columnName,\n        columnsByName: getColumnsByName(columnCopy)\n      };\n\n    case \"GLOBAL_FILTER\":\n      filteredRows = action.filter(state.originalRows);\n      selectedRowsById = {};\n      state.selectedRows.forEach(row => {\n        var _row$selected;\n\n        selectedRowsById[row.id] = (_row$selected = row.selected) !== null && _row$selected !== void 0 ? _row$selected : false;\n      });\n      return { ...state,\n        rows: filteredRows.map(row => {\n          return selectedRowsById[row.id] ? { ...row,\n            selected: selectedRowsById[row.id]\n          } : { ...row\n          };\n        }),\n        filterOn: true\n      };\n\n    case \"SELECT_ROW\":\n      stateCopy = { ...state\n      };\n      stateCopy.rows = stateCopy.rows.map(row => {\n        const newRow = { ...row\n        };\n\n        if (newRow.id === action.rowId) {\n          newRow.selected = !newRow.selected;\n        }\n\n        return newRow;\n      });\n      stateCopy.originalRows = stateCopy.originalRows.map(row => {\n        const newRow = { ...row\n        };\n\n        if (newRow.id === action.rowId) {\n          newRow.selected = !newRow.selected;\n        }\n\n        return newRow;\n      });\n      stateCopy.selectedRows = stateCopy.originalRows.filter(row => row.selected === true);\n      stateCopy.toggleAllState = stateCopy.selectedRows.length === stateCopy.rows.length ? stateCopy.toggleAllState = true : stateCopy.toggleAllState = false;\n      return stateCopy;\n\n    case \"SEARCH_STRING\":\n      stateCopy = { ...state\n      };\n      stateCopy.rows = stateCopy.originalRows.filter(row => {\n        return row.cells.filter(cell => {\n          if (cell.value.includes(action.searchString)) {\n            return true;\n          }\n\n          return false;\n        }).length > 0;\n      });\n      return stateCopy;\n\n    case \"TOGGLE_ALL\":\n      if (state.selectedRows.length < state.rows.length) {\n        stateCopy.rows = stateCopy.rows.map(row => {\n          rowIds[row.id] = true;\n          return { ...row,\n            selected: true\n          };\n        });\n        stateCopy.toggleAllState = true;\n      } else {\n        stateCopy.rows = stateCopy.rows.map(row => {\n          rowIds[row.id] = false;\n          return { ...row,\n            selected: false\n          };\n        });\n        stateCopy.toggleAllState = false;\n      }\n\n      stateCopy.originalRows = stateCopy.originalRows.map(row => {\n        return row.id in rowIds ? { ...row,\n          selected: rowIds[row.id]\n        } : { ...row\n        };\n      });\n      stateCopy.selectedRows = stateCopy.originalRows.filter(row => row.selected);\n      return stateCopy;\n\n    default:\n      throw new Error(\"Invalid reducer action\");\n  }\n};\n\nconst sortDataInOrder = (data, columns) => {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return data.map(row => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const newRow = {};\n    columns.forEach(column => {\n      if (!(column.name in row)) {\n        throw new Error(`Invalid row data, ${column.name} not found`);\n      }\n\n      newRow[column.name] = row[column.name];\n    });\n    return newRow;\n  });\n};\n\nexport const makeRender = (value, render, row) => {\n  return render ? () => render({\n    row,\n    value\n  }) : () => value;\n};\n\nconst makeHeaderRender = (label, render) => {\n  return render ? () => render({\n    label\n  }) : () => label;\n};\n\nexport const useTable = (columns, data, options) => {\n  _s();\n\n  const columnsWithSorting = useMemo(() => columns.map(column => {\n    return { ...column,\n      label: column.label ? column.label : column.name,\n      hidden: column.hidden ? column.hidden : false,\n      sort: column.sort,\n      sorted: {\n        on: false,\n        asc: false\n      }\n    };\n  }), [columns]);\n  const columnsByName = useMemo(() => getColumnsByName(columnsWithSorting), [columnsWithSorting]);\n  const tableData = useMemo(() => {\n    const sortedData = sortDataInOrder(data, columnsWithSorting);\n    const newData = sortedData.map((row, idx) => {\n      return {\n        id: idx,\n        selected: false,\n        hidden: false,\n        original: row,\n        cells: Object.entries(row).map(_ref => {\n          let [column, value] = _ref;\n          return {\n            hidden: columnsByName[column].hidden,\n            field: column,\n            value,\n            render: makeRender(value, columnsByName[column].render, row)\n          };\n        }).filter(cell => !cell.hidden)\n      };\n    });\n    return newData;\n  }, [data, columnsWithSorting, columnsByName]);\n  const reducer = createReducer();\n  const [state, dispatch] = useReducer(reducer, {\n    columns: columnsWithSorting,\n    columnsByName,\n    originalRows: tableData,\n    rows: tableData,\n    selectedRows: [],\n    toggleAllState: false,\n    filterOn: !!(options !== null && options !== void 0 && options.filter),\n    sortColumn: options === null || options === void 0 ? void 0 : options.sortColumn,\n    paginationEnabled: !!(options !== null && options !== void 0 && options.pagination),\n    pagination: {\n      page: 1,\n      perPage: 10,\n      canNext: true,\n      canPrev: false,\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n      nextPage: noop,\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n      prevPage: noop\n    }\n  });\n  state.pagination.nextPage = useCallback(() => {\n    dispatch({\n      type: \"NEXT_PAGE\"\n    });\n  }, [dispatch]);\n  state.pagination.prevPage = useCallback(() => dispatch({\n    type: \"PREV_PAGE\"\n  }), [dispatch]);\n  useEffect(() => {\n    dispatch({\n      type: \"SET_ROWS\",\n      data: tableData\n    });\n  }, [tableData]);\n  const headers = useMemo(() => {\n    return [...state.columns.map(column => {\n      const label = column.label ? column.label : column.name;\n      return { ...column,\n        render: makeHeaderRender(label, column.headerRender)\n      };\n    })];\n  }, [state.columns]);\n  useEffect(() => {\n    if (options && options.filter) {\n      dispatch({\n        type: \"GLOBAL_FILTER\",\n        filter: options.filter\n      });\n    }\n  });\n  return {\n    headers: headers.filter(column => !column.hidden),\n    rows: state.rows,\n    originalRows: state.originalRows,\n    selectedRows: state.selectedRows,\n    dispatch,\n    selectRow: rowId => dispatch({\n      type: \"SELECT_ROW\",\n      rowId\n    }),\n    toggleAll: () => dispatch({\n      type: \"TOGGLE_ALL\"\n    }),\n    toggleSort: (columnName, isAscOverride) => dispatch({\n      type: \"TOGGLE_SORT\",\n      columnName,\n      isAscOverride\n    }),\n    setSearchString: searchString => dispatch({\n      type: \"SEARCH_STRING\",\n      searchString\n    }),\n    pagination: state.pagination,\n    toggleAllState: state.toggleAllState\n  };\n};\n\n_s(useTable, \"rioZksOEwfWwWlkM0iAPX9dTf9k=\");","map":{"version":3,"sources":["D:/new/1TronicSwap-Build/src/components/_uikit/components/Table/hooks.tsx"],"names":["useMemo","useReducer","useEffect","useCallback","noop","byTextAscending","byTextDescending","sortByColumn","data","sortColumn","columns","isAscending","sortedRows","forEach","column","name","sorted","asc","sort","reverse","object","original","getPaginatedData","rows","perPage","page","start","end","slice","getColumnsByName","columnsByName","col","label","render","hidden","createReducer","state","action","nextPage","prevPage","columnCopy","filteredRows","selectedRowsById","stateCopy","rowIds","type","paginationEnabled","pagination","map","on","originalRows","canNext","length","canPrev","columnName","Error","isAscOverride","undefined","filter","selectedRows","row","id","selected","filterOn","newRow","rowId","toggleAllState","cells","cell","value","includes","searchString","sortDataInOrder","makeRender","makeHeaderRender","useTable","options","columnsWithSorting","tableData","sortedData","newData","idx","Object","entries","field","reducer","dispatch","headers","headerRender","selectRow","toggleAll","toggleSort","setSearchString"],"mappings":"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","sourcesContent":["import { useMemo, useReducer, useEffect, ReactNode, useCallback } from \"react\";\r\nimport noop from \"lodash/noop\";\r\n\r\nimport {\r\n  ColumnByNamesType,\r\n  ColumnType,\r\n  TableState,\r\n  TableAction,\r\n  DataType,\r\n  UseTableReturnType,\r\n  UseTableOptionsType,\r\n  RowType,\r\n  HeaderType,\r\n  HeaderRenderType,\r\n  ColumnStateType,\r\n} from \"./types\";\r\nimport { byTextAscending, byTextDescending } from \"./utils\";\r\n\r\nconst sortByColumn = <T extends DataType>(\r\n  data: RowType<T>[],\r\n  sortColumn: string,\r\n  columns: ColumnStateType<T>[]\r\n): RowType<T>[] => {\r\n  let isAscending = null;\r\n  let sortedRows: RowType<T>[] = [...data];\r\n\r\n  columns.forEach((column) => {\r\n    // if the row was found\r\n    if (sortColumn === column.name) {\r\n      isAscending = column.sorted.asc;\r\n\r\n      if (column.sort) {\r\n        sortedRows = isAscending ? data.sort(column.sort) : data.sort(column.sort).reverse();\r\n        // default to sort by string\r\n      } else {\r\n        sortedRows = isAscending\r\n          ? data.sort(byTextAscending((object) => object.original[sortColumn]))\r\n          : data.sort(byTextDescending((object) => object.original[sortColumn]));\r\n      }\r\n    }\r\n  });\r\n\r\n  return sortedRows;\r\n};\r\n\r\nconst getPaginatedData = <T extends DataType>(rows: RowType<T>[], perPage: number, page: number) => {\r\n  const start = (page - 1) * perPage;\r\n  const end = start + perPage;\r\n  return rows.slice(start, end);\r\n};\r\n\r\nconst getColumnsByName = <T extends DataType>(columns: ColumnType<T>[]): ColumnByNamesType<T> => {\r\n  const columnsByName: ColumnByNamesType<T> = {};\r\n  columns.forEach((column) => {\r\n    const col: ColumnType<T> = {\r\n      name: column.name,\r\n      label: column.label,\r\n    };\r\n\r\n    if (column.render) {\r\n      col.render = column.render;\r\n    }\r\n    col.hidden = column.hidden;\r\n    columnsByName[column.name] = col;\r\n  });\r\n\r\n  return columnsByName;\r\n};\r\n\r\nconst createReducer =\r\n  <T extends DataType>() =>\r\n  (state: TableState<T>, action: TableAction<T>): TableState<T> => {\r\n    let rows = [];\r\n    let nextPage = 0;\r\n    let prevPage = 0;\r\n    let isAscending = null;\r\n    let sortedRows: RowType<T>[] = [];\r\n    let columnCopy = [];\r\n    let filteredRows = [];\r\n    let selectedRowsById: { [key: number]: boolean } = {};\r\n    let stateCopy: TableState<T> = { ...state };\r\n    const rowIds: { [key: number]: boolean } = {};\r\n\r\n    switch (action.type) {\r\n      case \"SET_ROWS\":\r\n        rows = [...action.data];\r\n        // preserve sorting if a sort is already enabled when data changes\r\n        if (state.sortColumn) {\r\n          rows = sortByColumn(action.data, state.sortColumn, state.columns);\r\n        }\r\n\r\n        if (state.paginationEnabled === true) {\r\n          rows = getPaginatedData(rows, state.pagination.perPage, state.pagination.page);\r\n        }\r\n\r\n        if (state.paginationEnabled === true) {\r\n          rows = getPaginatedData(rows, state.pagination.perPage, state.pagination.page);\r\n        }\r\n\r\n        columnCopy = state.columns.map((column) => {\r\n          if (state.sortColumn === column.name) {\r\n            return {\r\n              ...column,\r\n              sorted: {\r\n                on: true,\r\n                asc: column.sorted.asc,\r\n              },\r\n            };\r\n          }\r\n\r\n          return column;\r\n        });\r\n\r\n        return {\r\n          ...state,\r\n          rows,\r\n          originalRows: action.data,\r\n          columns: columnCopy,\r\n        };\r\n\r\n      case \"NEXT_PAGE\":\r\n        nextPage = state.pagination.page + 1;\r\n        return {\r\n          ...state,\r\n          rows: getPaginatedData(state.originalRows, state.pagination.perPage, nextPage),\r\n          pagination: {\r\n            ...state.pagination,\r\n            page: nextPage,\r\n            canNext: nextPage * state.pagination.perPage < state.originalRows.length,\r\n            canPrev: nextPage !== 1,\r\n          },\r\n        };\r\n      case \"PREV_PAGE\":\r\n        prevPage = state.pagination.page === 1 ? 1 : state.pagination.page - 1;\r\n\r\n        return {\r\n          ...state,\r\n          rows: getPaginatedData(state.originalRows, state.pagination.perPage, prevPage),\r\n          pagination: {\r\n            ...state.pagination,\r\n            page: prevPage,\r\n            canNext: prevPage * state.pagination.perPage < state.originalRows.length,\r\n            canPrev: prevPage !== 1,\r\n          },\r\n        };\r\n      case \"TOGGLE_SORT\":\r\n        if (!(action.columnName in state.columnsByName)) {\r\n          throw new Error(`Invalid column, ${action.columnName} not found`);\r\n        }\r\n\r\n        // loop through all columns and set the sort parameter to off unless\r\n        // it's the specified column (only one column at a time for )\r\n        columnCopy = state.columns.map((column) => {\r\n          // if the row was found\r\n          if (action.columnName === column.name) {\r\n            if (action.isAscOverride !== undefined) {\r\n              // force the sort order\r\n              isAscending = action.isAscOverride;\r\n            } else {\r\n              // if it's undefined, start by setting to ascending, otherwise toggle\r\n              isAscending = column.sorted.asc === undefined ? true : !column.sorted.asc;\r\n            }\r\n\r\n            if (column.sort) {\r\n              sortedRows = isAscending ? state.rows.sort(column.sort) : state.rows.sort(column.sort).reverse();\r\n              // default to sort by string\r\n            } else {\r\n              sortedRows = isAscending\r\n                ? state.rows.sort(byTextAscending((object) => object.original[action.columnName]))\r\n                : state.rows.sort(byTextDescending((object) => object.original[action.columnName]));\r\n            }\r\n            return {\r\n              ...column,\r\n              sorted: {\r\n                on: true,\r\n                asc: isAscending,\r\n              },\r\n            };\r\n          }\r\n          // set sorting to false for all other columns\r\n          return {\r\n            ...column,\r\n            sorted: {\r\n              on: false,\r\n              asc: false,\r\n            },\r\n          };\r\n        });\r\n\r\n        return {\r\n          ...state,\r\n          columns: columnCopy,\r\n          rows: sortedRows,\r\n          sortColumn: action.columnName,\r\n          columnsByName: getColumnsByName(columnCopy),\r\n        };\r\n      case \"GLOBAL_FILTER\":\r\n        filteredRows = action.filter(state.originalRows);\r\n        selectedRowsById = {};\r\n        state.selectedRows.forEach((row) => {\r\n          selectedRowsById[row.id] = row.selected ?? false;\r\n        });\r\n\r\n        return {\r\n          ...state,\r\n          rows: filteredRows.map((row) => {\r\n            return selectedRowsById[row.id] ? { ...row, selected: selectedRowsById[row.id] } : { ...row };\r\n          }),\r\n          filterOn: true,\r\n        };\r\n      case \"SELECT_ROW\":\r\n        stateCopy = { ...state };\r\n\r\n        stateCopy.rows = stateCopy.rows.map((row) => {\r\n          const newRow = { ...row };\r\n          if (newRow.id === action.rowId) {\r\n            newRow.selected = !newRow.selected;\r\n          }\r\n          return newRow;\r\n        });\r\n\r\n        stateCopy.originalRows = stateCopy.originalRows.map((row) => {\r\n          const newRow = { ...row };\r\n          if (newRow.id === action.rowId) {\r\n            newRow.selected = !newRow.selected;\r\n          }\r\n          return newRow;\r\n        });\r\n\r\n        stateCopy.selectedRows = stateCopy.originalRows.filter((row) => row.selected === true);\r\n\r\n        stateCopy.toggleAllState =\r\n          stateCopy.selectedRows.length === stateCopy.rows.length\r\n            ? (stateCopy.toggleAllState = true)\r\n            : (stateCopy.toggleAllState = false);\r\n\r\n        return stateCopy;\r\n      case \"SEARCH_STRING\":\r\n        stateCopy = { ...state };\r\n        stateCopy.rows = stateCopy.originalRows.filter((row) => {\r\n          return (\r\n            row.cells.filter((cell) => {\r\n              if (cell.value.includes(action.searchString)) {\r\n                return true;\r\n              }\r\n              return false;\r\n            }).length > 0\r\n          );\r\n        });\r\n        return stateCopy;\r\n      case \"TOGGLE_ALL\":\r\n        if (state.selectedRows.length < state.rows.length) {\r\n          stateCopy.rows = stateCopy.rows.map((row) => {\r\n            rowIds[row.id] = true;\r\n            return { ...row, selected: true };\r\n          });\r\n\r\n          stateCopy.toggleAllState = true;\r\n        } else {\r\n          stateCopy.rows = stateCopy.rows.map((row) => {\r\n            rowIds[row.id] = false;\r\n\r\n            return { ...row, selected: false };\r\n          });\r\n          stateCopy.toggleAllState = false;\r\n        }\r\n\r\n        stateCopy.originalRows = stateCopy.originalRows.map((row) => {\r\n          return row.id in rowIds ? { ...row, selected: rowIds[row.id] } : { ...row };\r\n        });\r\n\r\n        stateCopy.selectedRows = stateCopy.originalRows.filter((row) => row.selected);\r\n\r\n        return stateCopy;\r\n      default:\r\n        throw new Error(\"Invalid reducer action\");\r\n    }\r\n  };\r\n\r\nconst sortDataInOrder = <T extends DataType>(data: T[], columns: ColumnType<T>[]): T[] => {\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  return data.map((row: any) => {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    const newRow: any = {};\r\n    columns.forEach((column) => {\r\n      if (!(column.name in row)) {\r\n        throw new Error(`Invalid row data, ${column.name} not found`);\r\n      }\r\n      newRow[column.name] = row[column.name];\r\n    });\r\n    return newRow;\r\n  });\r\n};\r\n\r\nexport const makeRender = <T extends DataType>(\r\n  // eslint-disable-next-line\r\n  value: any,\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  render: (({ value: val, row }: { value: any; row: T }) => ReactNode) | undefined,\r\n  row: T\r\n): (() => React.ReactNode) => {\r\n  return render ? () => render({ row, value }) : () => value;\r\n};\r\n\r\nconst makeHeaderRender = (label: string, render?: HeaderRenderType) => {\r\n  return render ? () => render({ label }) : () => label;\r\n};\r\n\r\nexport const useTable = <T extends DataType>(\r\n  columns: ColumnType<T>[],\r\n  data: T[],\r\n  options?: UseTableOptionsType<T>\r\n): UseTableReturnType<T> => {\r\n  const columnsWithSorting: ColumnStateType<T>[] = useMemo(\r\n    () =>\r\n      columns.map((column) => {\r\n        return {\r\n          ...column,\r\n          label: column.label ? column.label : column.name,\r\n          hidden: column.hidden ? column.hidden : false,\r\n          sort: column.sort,\r\n          sorted: {\r\n            on: false,\r\n            asc: false,\r\n          },\r\n        };\r\n      }),\r\n    [columns]\r\n  );\r\n  const columnsByName = useMemo(() => getColumnsByName(columnsWithSorting), [columnsWithSorting]);\r\n\r\n  const tableData: RowType<T>[] = useMemo(() => {\r\n    const sortedData = sortDataInOrder(data, columnsWithSorting);\r\n\r\n    const newData = sortedData.map((row, idx) => {\r\n      return {\r\n        id: idx,\r\n        selected: false,\r\n        hidden: false,\r\n        original: row,\r\n        cells: Object.entries(row)\r\n          .map(([column, value]) => {\r\n            return {\r\n              hidden: columnsByName[column].hidden,\r\n              field: column,\r\n              value,\r\n              render: makeRender(value, columnsByName[column].render, row),\r\n            };\r\n          })\r\n          .filter((cell) => !cell.hidden),\r\n      };\r\n    });\r\n    return newData;\r\n  }, [data, columnsWithSorting, columnsByName]);\r\n\r\n  const reducer = createReducer<T>();\r\n\r\n  const [state, dispatch] = useReducer(reducer, {\r\n    columns: columnsWithSorting,\r\n    columnsByName,\r\n    originalRows: tableData,\r\n    rows: tableData,\r\n    selectedRows: [],\r\n    toggleAllState: false,\r\n    filterOn: !!options?.filter,\r\n    sortColumn: options?.sortColumn,\r\n    paginationEnabled: !!options?.pagination,\r\n    pagination: {\r\n      page: 1,\r\n      perPage: 10,\r\n      canNext: true,\r\n      canPrev: false,\r\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n      nextPage: noop,\r\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n      prevPage: noop,\r\n    },\r\n  });\r\n\r\n  state.pagination.nextPage = useCallback(() => {\r\n    dispatch({ type: \"NEXT_PAGE\" });\r\n  }, [dispatch]);\r\n  state.pagination.prevPage = useCallback(() => dispatch({ type: \"PREV_PAGE\" }), [dispatch]);\r\n\r\n  useEffect(() => {\r\n    dispatch({ type: \"SET_ROWS\", data: tableData });\r\n  }, [tableData]);\r\n\r\n  const headers: HeaderType<T>[] = useMemo(() => {\r\n    return [\r\n      ...state.columns.map((column) => {\r\n        const label = column.label ? column.label : column.name;\r\n        return {\r\n          ...column,\r\n          render: makeHeaderRender(label, column.headerRender),\r\n        };\r\n      }),\r\n    ];\r\n  }, [state.columns]);\r\n\r\n  useEffect(() => {\r\n    if (options && options.filter) {\r\n      dispatch({ type: \"GLOBAL_FILTER\", filter: options.filter });\r\n    }\r\n  });\r\n\r\n  return {\r\n    headers: headers.filter((column) => !column.hidden),\r\n    rows: state.rows,\r\n    originalRows: state.originalRows,\r\n    selectedRows: state.selectedRows,\r\n    dispatch,\r\n    selectRow: (rowId: number) => dispatch({ type: \"SELECT_ROW\", rowId }),\r\n    toggleAll: () => dispatch({ type: \"TOGGLE_ALL\" }),\r\n    toggleSort: (columnName: string, isAscOverride?: boolean) =>\r\n      dispatch({ type: \"TOGGLE_SORT\", columnName, isAscOverride }),\r\n    setSearchString: (searchString: string) => dispatch({ type: \"SEARCH_STRING\", searchString }),\r\n    pagination: state.pagination,\r\n    toggleAllState: state.toggleAllState,\r\n  };\r\n};\r\n"]},"metadata":{},"sourceType":"module"}