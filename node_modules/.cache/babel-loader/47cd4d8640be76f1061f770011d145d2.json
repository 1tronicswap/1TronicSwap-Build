{"ast":null,"code":"import invariant from 'tiny-invariant';\nimport JSBI from 'jsbi';\nimport { pack, keccak256 } from '@ethersproject/solidity';\nimport { getCreate2Address } from '@ethersproject/address';\nimport { Price } from './fractions/price';\nimport { TokenAmount } from './fractions/tokenAmount';\nimport { FACTORY_ADDRESS, INIT_CODE_HASH, MINIMUM_LIQUIDITY, ZERO, ONE, FIVE, FEES_NUMERATOR, FEES_DENOMINATOR } from '../constants';\nimport { sqrt, parseBigintIsh } from '../utils';\nimport { InsufficientReservesError, InsufficientInputAmountError } from '../errors';\nimport { Token } from './token';\nlet PAIR_ADDRESS_CACHE = {};\nexport class Pair {\n  static getAddress(tokenA, tokenB) {\n    var _PAIR_ADDRESS_CACHE, _PAIR_ADDRESS_CACHE$t;\n\n    const tokens = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]; // does safety checks\n\n    if (((_PAIR_ADDRESS_CACHE = PAIR_ADDRESS_CACHE) === null || _PAIR_ADDRESS_CACHE === void 0 ? void 0 : (_PAIR_ADDRESS_CACHE$t = _PAIR_ADDRESS_CACHE[tokens[0].address]) === null || _PAIR_ADDRESS_CACHE$t === void 0 ? void 0 : _PAIR_ADDRESS_CACHE$t[tokens[1].address]) === undefined) {\n      var _PAIR_ADDRESS_CACHE2;\n\n      PAIR_ADDRESS_CACHE = { ...PAIR_ADDRESS_CACHE,\n        [tokens[0].address]: { ...((_PAIR_ADDRESS_CACHE2 = PAIR_ADDRESS_CACHE) === null || _PAIR_ADDRESS_CACHE2 === void 0 ? void 0 : _PAIR_ADDRESS_CACHE2[tokens[0].address]),\n          [tokens[1].address]: getCreate2Address(FACTORY_ADDRESS, keccak256(['bytes'], [pack(['address', 'address'], [tokens[0].address, tokens[1].address])]), INIT_CODE_HASH)\n        }\n      };\n    }\n\n    return PAIR_ADDRESS_CACHE[tokens[0].address][tokens[1].address];\n  }\n\n  constructor(tokenAmountA, tokenAmountB) {\n    this.liquidityToken = void 0;\n    this.tokenAmounts = void 0;\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n    ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA];\n    this.liquidityToken = new Token(tokenAmounts[0].token.chainId, Pair.getAddress(tokenAmounts[0].token, tokenAmounts[1].token), 18, '1TRC-LP', 'OneTronic LPs');\n    this.tokenAmounts = tokenAmounts;\n  }\n  /**\r\n   * Returns true if the token is either token0 or token1\r\n   * @param token to check\r\n   */\n\n\n  involvesToken(token) {\n    return token.equals(this.token0) || token.equals(this.token1);\n  }\n  /**\r\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\r\n   */\n\n\n  get token0Price() {\n    return new Price(this.token0, this.token1, this.tokenAmounts[0].raw, this.tokenAmounts[1].raw);\n  }\n  /**\r\n   * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\r\n   */\n\n\n  get token1Price() {\n    return new Price(this.token1, this.token0, this.tokenAmounts[1].raw, this.tokenAmounts[0].raw);\n  }\n  /**\r\n   * Return the price of the given token in terms of the other token in the pair.\r\n   * @param token token to return price of\r\n   */\n\n\n  priceOf(token) {\n    invariant(this.involvesToken(token), 'TOKEN');\n    return token.equals(this.token0) ? this.token0Price : this.token1Price;\n  }\n  /**\r\n   * Returns the chain ID of the tokens in the pair.\r\n   */\n\n\n  get chainId() {\n    return this.token0.chainId;\n  }\n\n  get token0() {\n    return this.tokenAmounts[0].token;\n  }\n\n  get token1() {\n    return this.tokenAmounts[1].token;\n  }\n\n  get reserve0() {\n    return this.tokenAmounts[0];\n  }\n\n  get reserve1() {\n    return this.tokenAmounts[1];\n  }\n\n  reserveOf(token) {\n    invariant(this.involvesToken(token), 'TOKEN');\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1;\n  }\n\n  getOutputAmount(inputAmount) {\n    invariant(this.involvesToken(inputAmount.token), 'TOKEN');\n\n    if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO)) {\n      throw new InsufficientReservesError();\n    }\n\n    const inputReserve = this.reserveOf(inputAmount.token);\n    const outputReserve = this.reserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0);\n    const inputAmountWithFee = JSBI.multiply(inputAmount.raw, FEES_NUMERATOR);\n    const numerator = JSBI.multiply(inputAmountWithFee, outputReserve.raw);\n    const denominator = JSBI.add(JSBI.multiply(inputReserve.raw, FEES_DENOMINATOR), inputAmountWithFee);\n    const outputAmount = new TokenAmount(inputAmount.token.equals(this.token0) ? this.token1 : this.token0, JSBI.divide(numerator, denominator));\n\n    if (JSBI.equal(outputAmount.raw, ZERO)) {\n      throw new InsufficientInputAmountError();\n    }\n\n    return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];\n  }\n\n  getInputAmount(outputAmount) {\n    invariant(this.involvesToken(outputAmount.token), 'TOKEN');\n\n    if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO) || JSBI.greaterThanOrEqual(outputAmount.raw, this.reserveOf(outputAmount.token).raw)) {\n      throw new InsufficientReservesError();\n    }\n\n    const outputReserve = this.reserveOf(outputAmount.token);\n    const inputReserve = this.reserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0);\n    const numerator = JSBI.multiply(JSBI.multiply(inputReserve.raw, outputAmount.raw), FEES_DENOMINATOR);\n    const denominator = JSBI.multiply(JSBI.subtract(outputReserve.raw, outputAmount.raw), FEES_NUMERATOR);\n    const inputAmount = new TokenAmount(outputAmount.token.equals(this.token0) ? this.token1 : this.token0, JSBI.add(JSBI.divide(numerator, denominator), ONE));\n    return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];\n  }\n\n  getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB) {\n    invariant(totalSupply.token.equals(this.liquidityToken), 'LIQUIDITY');\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n    ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA];\n    invariant(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1), 'TOKEN');\n    let liquidity;\n\n    if (JSBI.equal(totalSupply.raw, ZERO)) {\n      liquidity = JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].raw, tokenAmounts[1].raw)), MINIMUM_LIQUIDITY);\n    } else {\n      const amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].raw, totalSupply.raw), this.reserve0.raw);\n      const amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].raw, totalSupply.raw), this.reserve1.raw);\n      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1;\n    }\n\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError();\n    }\n\n    return new TokenAmount(this.liquidityToken, liquidity);\n  }\n\n  getLiquidityValue(token, totalSupply, liquidity) {\n    let feeOn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let kLast = arguments.length > 4 ? arguments[4] : undefined;\n    invariant(this.involvesToken(token), 'TOKEN');\n    invariant(totalSupply.token.equals(this.liquidityToken), 'TOTAL_SUPPLY');\n    invariant(liquidity.token.equals(this.liquidityToken), 'LIQUIDITY');\n    invariant(JSBI.lessThanOrEqual(liquidity.raw, totalSupply.raw), 'LIQUIDITY');\n    let totalSupplyAdjusted;\n\n    if (!feeOn) {\n      totalSupplyAdjusted = totalSupply;\n    } else {\n      invariant(!!kLast, 'K_LAST');\n      const kLastParsed = parseBigintIsh(kLast);\n\n      if (!JSBI.equal(kLastParsed, ZERO)) {\n        const rootK = sqrt(JSBI.multiply(this.reserve0.raw, this.reserve1.raw));\n        const rootKLast = sqrt(kLastParsed);\n\n        if (JSBI.greaterThan(rootK, rootKLast)) {\n          const numerator = JSBI.multiply(totalSupply.raw, JSBI.subtract(rootK, rootKLast));\n          const denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast);\n          const feeLiquidity = JSBI.divide(numerator, denominator);\n          totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity));\n        } else {\n          totalSupplyAdjusted = totalSupply;\n        }\n      } else {\n        totalSupplyAdjusted = totalSupply;\n      }\n    }\n\n    return new TokenAmount(token, JSBI.divide(JSBI.multiply(liquidity.raw, this.reserveOf(token).raw), totalSupplyAdjusted.raw));\n  }\n\n}","map":{"version":3,"sources":["D:/new/1TronicSwap-Build/src/utils/@sdk/entities/pair.ts"],"names":["invariant","JSBI","pack","keccak256","getCreate2Address","Price","TokenAmount","FACTORY_ADDRESS","INIT_CODE_HASH","MINIMUM_LIQUIDITY","ZERO","ONE","FIVE","FEES_NUMERATOR","FEES_DENOMINATOR","sqrt","parseBigintIsh","InsufficientReservesError","InsufficientInputAmountError","Token","PAIR_ADDRESS_CACHE","Pair","getAddress","tokenA","tokenB","tokens","sortsBefore","address","undefined","constructor","tokenAmountA","tokenAmountB","liquidityToken","tokenAmounts","token","chainId","involvesToken","equals","token0","token1","token0Price","raw","token1Price","priceOf","reserve0","reserve1","reserveOf","getOutputAmount","inputAmount","equal","inputReserve","outputReserve","inputAmountWithFee","multiply","numerator","denominator","add","outputAmount","divide","subtract","getInputAmount","greaterThanOrEqual","getLiquidityMinted","totalSupply","liquidity","amount0","amount1","lessThanOrEqual","greaterThan","getLiquidityValue","feeOn","kLast","totalSupplyAdjusted","kLastParsed","rootK","rootKLast","feeLiquidity"],"mappings":"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","sourcesContent":["import invariant from 'tiny-invariant'\r\nimport JSBI from 'jsbi'\r\nimport { pack, keccak256 } from '@ethersproject/solidity'\r\nimport { getCreate2Address } from '@ethersproject/address'\r\nimport { Price } from './fractions/price'\r\nimport { TokenAmount } from './fractions/tokenAmount'\r\n\r\nimport {\r\n  BigintIsh,\r\n  FACTORY_ADDRESS,\r\n  INIT_CODE_HASH,\r\n  MINIMUM_LIQUIDITY,\r\n  ZERO,\r\n  ONE,\r\n  FIVE,\r\n  FEES_NUMERATOR,\r\n  FEES_DENOMINATOR,\r\n  ChainId,\r\n} from '../constants'\r\nimport { sqrt, parseBigintIsh } from '../utils'\r\nimport { InsufficientReservesError, InsufficientInputAmountError } from '../errors'\r\nimport { Token } from './token'\r\n\r\nlet PAIR_ADDRESS_CACHE: { [token0Address: string]: { [token1Address: string]: string } } = {}\r\n\r\nexport class Pair {\r\n  public readonly liquidityToken: Token\r\n  private readonly tokenAmounts: [TokenAmount, TokenAmount]\r\n\r\n  public static getAddress(tokenA: Token, tokenB: Token): string {\r\n    const tokens = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] // does safety checks\r\n\r\n    if (PAIR_ADDRESS_CACHE?.[tokens[0].address]?.[tokens[1].address] === undefined) {\r\n      PAIR_ADDRESS_CACHE = {\r\n        ...PAIR_ADDRESS_CACHE,\r\n        [tokens[0].address]: {\r\n          ...PAIR_ADDRESS_CACHE?.[tokens[0].address],\r\n          [tokens[1].address]: getCreate2Address(\r\n            FACTORY_ADDRESS,\r\n            keccak256(['bytes'], [pack(['address', 'address'], [tokens[0].address, tokens[1].address])]),\r\n            INIT_CODE_HASH\r\n          ),\r\n        },\r\n      }\r\n    }\r\n\r\n    return PAIR_ADDRESS_CACHE[tokens[0].address][tokens[1].address]\r\n  }\r\n\r\n  public constructor(tokenAmountA: TokenAmount, tokenAmountB: TokenAmount) {\r\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\r\n      ? [tokenAmountA, tokenAmountB]\r\n      : [tokenAmountB, tokenAmountA]\r\n    this.liquidityToken = new Token(\r\n      tokenAmounts[0].token.chainId,\r\n      Pair.getAddress(tokenAmounts[0].token, tokenAmounts[1].token),\r\n      18,\r\n      '1TRC-LP',\r\n      'OneTronic LPs'\r\n    )\r\n    this.tokenAmounts = tokenAmounts as [TokenAmount, TokenAmount]\r\n  }\r\n\r\n  /**\r\n   * Returns true if the token is either token0 or token1\r\n   * @param token to check\r\n   */\r\n  public involvesToken(token: Token): boolean {\r\n    return token.equals(this.token0) || token.equals(this.token1)\r\n  }\r\n\r\n  /**\r\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\r\n   */\r\n  public get token0Price(): Price {\r\n    return new Price(this.token0, this.token1, this.tokenAmounts[0].raw, this.tokenAmounts[1].raw)\r\n  }\r\n\r\n  /**\r\n   * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\r\n   */\r\n  public get token1Price(): Price {\r\n    return new Price(this.token1, this.token0, this.tokenAmounts[1].raw, this.tokenAmounts[0].raw)\r\n  }\r\n\r\n  /**\r\n   * Return the price of the given token in terms of the other token in the pair.\r\n   * @param token token to return price of\r\n   */\r\n  public priceOf(token: Token): Price {\r\n    invariant(this.involvesToken(token), 'TOKEN')\r\n    return token.equals(this.token0) ? this.token0Price : this.token1Price\r\n  }\r\n\r\n  /**\r\n   * Returns the chain ID of the tokens in the pair.\r\n   */\r\n  public get chainId(): ChainId {\r\n    return this.token0.chainId\r\n  }\r\n\r\n  public get token0(): Token {\r\n    return this.tokenAmounts[0].token\r\n  }\r\n\r\n  public get token1(): Token {\r\n    return this.tokenAmounts[1].token\r\n  }\r\n\r\n  public get reserve0(): TokenAmount {\r\n    return this.tokenAmounts[0]\r\n  }\r\n\r\n  public get reserve1(): TokenAmount {\r\n    return this.tokenAmounts[1]\r\n  }\r\n\r\n  public reserveOf(token: Token): TokenAmount {\r\n    invariant(this.involvesToken(token), 'TOKEN')\r\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1\r\n  }\r\n\r\n  public getOutputAmount(inputAmount: TokenAmount): [TokenAmount, Pair] {\r\n    invariant(this.involvesToken(inputAmount.token), 'TOKEN')\r\n    if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO)) {\r\n      throw new InsufficientReservesError()\r\n    }\r\n    const inputReserve = this.reserveOf(inputAmount.token)\r\n    const outputReserve = this.reserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0)\r\n    const inputAmountWithFee = JSBI.multiply(inputAmount.raw, FEES_NUMERATOR)\r\n    const numerator = JSBI.multiply(inputAmountWithFee, outputReserve.raw)\r\n    const denominator = JSBI.add(JSBI.multiply(inputReserve.raw, FEES_DENOMINATOR), inputAmountWithFee)\r\n    const outputAmount = new TokenAmount(\r\n      inputAmount.token.equals(this.token0) ? this.token1 : this.token0,\r\n      JSBI.divide(numerator, denominator)\r\n    )\r\n    if (JSBI.equal(outputAmount.raw, ZERO)) {\r\n      throw new InsufficientInputAmountError()\r\n    }\r\n    return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\r\n  }\r\n\r\n  public getInputAmount(outputAmount: TokenAmount): [TokenAmount, Pair] {\r\n    invariant(this.involvesToken(outputAmount.token), 'TOKEN')\r\n    if (\r\n      JSBI.equal(this.reserve0.raw, ZERO) ||\r\n      JSBI.equal(this.reserve1.raw, ZERO) ||\r\n      JSBI.greaterThanOrEqual(outputAmount.raw, this.reserveOf(outputAmount.token).raw)\r\n    ) {\r\n      throw new InsufficientReservesError()\r\n    }\r\n\r\n    const outputReserve = this.reserveOf(outputAmount.token)\r\n    const inputReserve = this.reserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0)\r\n    const numerator = JSBI.multiply(JSBI.multiply(inputReserve.raw, outputAmount.raw), FEES_DENOMINATOR)\r\n    const denominator = JSBI.multiply(JSBI.subtract(outputReserve.raw, outputAmount.raw), FEES_NUMERATOR)\r\n    const inputAmount = new TokenAmount(\r\n      outputAmount.token.equals(this.token0) ? this.token1 : this.token0,\r\n      JSBI.add(JSBI.divide(numerator, denominator), ONE)\r\n    )\r\n    return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\r\n  }\r\n\r\n  public getLiquidityMinted(\r\n    totalSupply: TokenAmount,\r\n    tokenAmountA: TokenAmount,\r\n    tokenAmountB: TokenAmount\r\n  ): TokenAmount {\r\n    invariant(totalSupply.token.equals(this.liquidityToken), 'LIQUIDITY')\r\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\r\n      ? [tokenAmountA, tokenAmountB]\r\n      : [tokenAmountB, tokenAmountA]\r\n    invariant(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1), 'TOKEN')\r\n\r\n    let liquidity: JSBI\r\n    if (JSBI.equal(totalSupply.raw, ZERO)) {\r\n      liquidity = JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].raw, tokenAmounts[1].raw)), MINIMUM_LIQUIDITY)\r\n    } else {\r\n      const amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].raw, totalSupply.raw), this.reserve0.raw)\r\n      const amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].raw, totalSupply.raw), this.reserve1.raw)\r\n      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1\r\n    }\r\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\r\n      throw new InsufficientInputAmountError()\r\n    }\r\n    return new TokenAmount(this.liquidityToken, liquidity)\r\n  }\r\n\r\n  public getLiquidityValue(\r\n    token: Token,\r\n    totalSupply: TokenAmount,\r\n    liquidity: TokenAmount,\r\n    feeOn: boolean = false,\r\n    kLast?: BigintIsh\r\n  ): TokenAmount {\r\n    invariant(this.involvesToken(token), 'TOKEN')\r\n    invariant(totalSupply.token.equals(this.liquidityToken), 'TOTAL_SUPPLY')\r\n    invariant(liquidity.token.equals(this.liquidityToken), 'LIQUIDITY')\r\n    invariant(JSBI.lessThanOrEqual(liquidity.raw, totalSupply.raw), 'LIQUIDITY')\r\n\r\n    let totalSupplyAdjusted: TokenAmount\r\n    if (!feeOn) {\r\n      totalSupplyAdjusted = totalSupply\r\n    } else {\r\n      invariant(!!kLast, 'K_LAST')\r\n      const kLastParsed = parseBigintIsh(kLast)\r\n      if (!JSBI.equal(kLastParsed, ZERO)) {\r\n        const rootK = sqrt(JSBI.multiply(this.reserve0.raw, this.reserve1.raw))\r\n        const rootKLast = sqrt(kLastParsed)\r\n        if (JSBI.greaterThan(rootK, rootKLast)) {\r\n          const numerator = JSBI.multiply(totalSupply.raw, JSBI.subtract(rootK, rootKLast))\r\n          const denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast)\r\n          const feeLiquidity = JSBI.divide(numerator, denominator)\r\n          totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity))\r\n        } else {\r\n          totalSupplyAdjusted = totalSupply\r\n        }\r\n      } else {\r\n        totalSupplyAdjusted = totalSupply\r\n      }\r\n    }\r\n\r\n    return new TokenAmount(\r\n      token,\r\n      JSBI.divide(JSBI.multiply(liquidity.raw, this.reserveOf(token).raw), totalSupplyAdjusted.raw)\r\n    )\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}