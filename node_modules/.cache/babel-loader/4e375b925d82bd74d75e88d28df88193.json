{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport BigNumber from 'bignumber.js';\nimport { LotteryStatus } from 'config/constants/types';\nimport lotteryV2Abi from 'config/abi/lotteryV2.json';\nimport { getLotteryV2Address } from 'utils/addressHelpers';\nimport { multicallv2 } from 'utils/multicall';\nimport { getLotteryV2Contract } from 'utils/contractHelpers';\nimport { useMemo } from 'react';\nimport { ethersToSerializedBigNumber } from 'utils/bigNumber';\nconst lotteryContract = getLotteryV2Contract(); // Variable used to determine how many past rounds should be populated by node data rather than subgraph\n\nexport const NUM_ROUNDS_TO_FETCH_FROM_NODES = 2;\n\nconst processViewLotterySuccessResponse = (response, lotteryId) => {\n  const {\n    status,\n    startTime,\n    endTime,\n    priceTicketInCake,\n    discountDivisor,\n    treasuryFee,\n    firstTicketId,\n    lastTicketId,\n    amountCollectedInCake,\n    finalNumber,\n    cakePerBracket,\n    countWinnersPerBracket,\n    rewardsBreakdown\n  } = response;\n  const statusKey = Object.keys(LotteryStatus)[status];\n  const serializedCakePerBracket = cakePerBracket.map(cakeInBracket => ethersToSerializedBigNumber(cakeInBracket));\n  const serializedCountWinnersPerBracket = countWinnersPerBracket.map(winnersInBracket => ethersToSerializedBigNumber(winnersInBracket));\n  const serializedRewardsBreakdown = rewardsBreakdown.map(reward => ethersToSerializedBigNumber(reward));\n  return {\n    isLoading: false,\n    lotteryId,\n    status: LotteryStatus[statusKey],\n    startTime: startTime === null || startTime === void 0 ? void 0 : startTime.toString(),\n    endTime: endTime === null || endTime === void 0 ? void 0 : endTime.toString(),\n    priceTicketInCake: ethersToSerializedBigNumber(priceTicketInCake),\n    discountDivisor: discountDivisor === null || discountDivisor === void 0 ? void 0 : discountDivisor.toString(),\n    treasuryFee: treasuryFee === null || treasuryFee === void 0 ? void 0 : treasuryFee.toString(),\n    firstTicketId: firstTicketId === null || firstTicketId === void 0 ? void 0 : firstTicketId.toString(),\n    lastTicketId: lastTicketId === null || lastTicketId === void 0 ? void 0 : lastTicketId.toString(),\n    amountCollectedInCake: ethersToSerializedBigNumber(amountCollectedInCake),\n    finalNumber,\n    cakePerBracket: serializedCakePerBracket,\n    countWinnersPerBracket: serializedCountWinnersPerBracket,\n    rewardsBreakdown: serializedRewardsBreakdown\n  };\n};\n\nconst processViewLotteryErrorResponse = lotteryId => {\n  return {\n    isLoading: true,\n    lotteryId,\n    status: LotteryStatus.PENDING,\n    startTime: '',\n    endTime: '',\n    priceTicketInCake: '',\n    discountDivisor: '',\n    treasuryFee: '',\n    firstTicketId: '',\n    lastTicketId: '',\n    amountCollectedInCake: '',\n    finalNumber: null,\n    cakePerBracket: [],\n    countWinnersPerBracket: [],\n    rewardsBreakdown: []\n  };\n};\n\nexport const fetchLottery = async lotteryId => {\n  try {\n    const lotteryData = await lotteryContract.viewLottery(lotteryId);\n    return processViewLotterySuccessResponse(lotteryData, lotteryId);\n  } catch (error) {\n    return processViewLotteryErrorResponse(lotteryId);\n  }\n};\nexport const fetchMultipleLotteries = async lotteryIds => {\n  const calls = lotteryIds.map(id => ({\n    name: 'viewLottery',\n    address: getLotteryV2Address(),\n    params: [id]\n  }));\n\n  try {\n    const multicallRes = await multicallv2(lotteryV2Abi, calls, {\n      requireSuccess: false\n    });\n    const processedResponses = multicallRes.map((res, index) => processViewLotterySuccessResponse(res[0], lotteryIds[index]));\n    return processedResponses;\n  } catch (error) {\n    console.error(error);\n    return calls.map((call, index) => processViewLotteryErrorResponse(lotteryIds[index]));\n  }\n};\nexport const fetchCurrentLotteryIdAndMaxBuy = async () => {\n  try {\n    const calls = ['currentLotteryId', 'maxNumberTicketsPerBuyOrClaim'].map(method => ({\n      address: getLotteryV2Address(),\n      name: method\n    }));\n    const [[currentLotteryId], [maxNumberTicketsPerBuyOrClaim]] = await multicallv2(lotteryV2Abi, calls);\n    return {\n      currentLotteryId: currentLotteryId ? currentLotteryId.toString() : null,\n      maxNumberTicketsPerBuyOrClaim: maxNumberTicketsPerBuyOrClaim ? maxNumberTicketsPerBuyOrClaim.toString() : null\n    };\n  } catch (error) {\n    return {\n      currentLotteryId: null,\n      maxNumberTicketsPerBuyOrClaim: null\n    };\n  }\n};\nexport const processRawTicketsResponse = ticketsResponse => {\n  const [ticketIds, ticketNumbers, ticketStatuses] = ticketsResponse;\n\n  if ((ticketIds === null || ticketIds === void 0 ? void 0 : ticketIds.length) > 0) {\n    return ticketIds.map((ticketId, index) => {\n      return {\n        id: ticketId.toString(),\n        number: ticketNumbers[index].toString(),\n        status: ticketStatuses[index]\n      };\n    });\n  }\n\n  return [];\n};\nexport const getViewUserTicketInfoCalls = (totalTicketsToRequest, account, lotteryId) => {\n  let cursor = 0;\n  const perRequestLimit = 100;\n  const calls = [];\n\n  for (let i = 0; i < totalTicketsToRequest; i += perRequestLimit) {\n    cursor = i;\n    calls.push({\n      name: 'viewUserInfoForLotteryId',\n      address: getLotteryV2Address(),\n      params: [account, lotteryId, cursor, perRequestLimit]\n    });\n  }\n\n  return calls;\n};\nexport const mergeViewUserTicketInfoMulticallResponse = response => {\n  const mergedMulticallResponse = [[], [], []];\n  response.forEach(ticketResponse => {\n    mergedMulticallResponse[0].push(...ticketResponse[0]);\n    mergedMulticallResponse[1].push(...ticketResponse[1]);\n    mergedMulticallResponse[2].push(...ticketResponse[2]);\n  });\n  return mergedMulticallResponse;\n};\nexport const fetchTickets = async (account, lotteryId, userTotalTickets) => {\n  // If the subgraph is returning user totalTickets data for the round - use those totalTickets, if not - batch request up to 4000\n  const totalTicketsToRequest = userTotalTickets ? parseInt(userTotalTickets, 10) : 4000;\n  const calls = getViewUserTicketInfoCalls(totalTicketsToRequest, account, lotteryId);\n\n  try {\n    const multicallRes = await multicallv2(lotteryV2Abi, calls, {\n      requireSuccess: false\n    }); // When using a static totalTicketsToRequest value - null responses may be returned\n\n    const filteredForNullResponses = multicallRes.filter(res => res);\n    const mergedMulticallResponse = mergeViewUserTicketInfoMulticallResponse(filteredForNullResponses);\n    const completeTicketData = processRawTicketsResponse(mergedMulticallResponse);\n    return completeTicketData;\n  } catch (error) {\n    console.error(error);\n    return null;\n  }\n};\nexport const getRoundIdsArray = currentLotteryId => {\n  // TODO: This returns a number, but the currentId being typed as a string is deep in the logic and needs untangling\n  const currentIdAsInt = parseInt(currentLotteryId, 10);\n  const roundIds = [];\n\n  for (let i = 0; i < NUM_ROUNDS_TO_FETCH_FROM_NODES; i++) {\n    roundIds.push(currentIdAsInt - i);\n  }\n\n  return roundIds;\n};\nexport const useProcessLotteryResponse = lotteryData => {\n  _s();\n\n  const {\n    priceTicketInCake: priceTicketInCakeAsString,\n    discountDivisor: discountDivisorAsString,\n    amountCollectedInCake: amountCollectedInCakeAsString\n  } = lotteryData;\n  const discountDivisor = useMemo(() => {\n    return new BigNumber(discountDivisorAsString);\n  }, [discountDivisorAsString]);\n  const priceTicketInCake = useMemo(() => {\n    return new BigNumber(priceTicketInCakeAsString);\n  }, [priceTicketInCakeAsString]);\n  const amountCollectedInCake = useMemo(() => {\n    return new BigNumber(amountCollectedInCakeAsString);\n  }, [amountCollectedInCakeAsString]);\n  return {\n    isLoading: lotteryData.isLoading,\n    lotteryId: lotteryData.lotteryId,\n    userTickets: lotteryData.userTickets,\n    status: lotteryData.status,\n    startTime: lotteryData.startTime,\n    endTime: lotteryData.endTime,\n    priceTicketInCake,\n    discountDivisor,\n    treasuryFee: lotteryData.treasuryFee,\n    firstTicketId: lotteryData.firstTicketId,\n    lastTicketId: lotteryData.lastTicketId,\n    amountCollectedInCake,\n    finalNumber: lotteryData.finalNumber,\n    cakePerBracket: lotteryData.cakePerBracket,\n    countWinnersPerBracket: lotteryData.countWinnersPerBracket,\n    rewardsBreakdown: lotteryData.rewardsBreakdown\n  };\n};\n\n_s(useProcessLotteryResponse, \"FnUdVBB2odZtpXQPLId0yuHMXOU=\");\n\nexport const hasRoundBeenClaimed = tickets => {\n  const claimedTickets = tickets.filter(ticket => ticket.status);\n  return claimedTickets.length > 0;\n};","map":{"version":3,"sources":["D:/new/1TronicSwap-Build/src/state/lottery/helpers.ts"],"names":["BigNumber","LotteryStatus","lotteryV2Abi","getLotteryV2Address","multicallv2","getLotteryV2Contract","useMemo","ethersToSerializedBigNumber","lotteryContract","NUM_ROUNDS_TO_FETCH_FROM_NODES","processViewLotterySuccessResponse","response","lotteryId","status","startTime","endTime","priceTicketInCake","discountDivisor","treasuryFee","firstTicketId","lastTicketId","amountCollectedInCake","finalNumber","cakePerBracket","countWinnersPerBracket","rewardsBreakdown","statusKey","Object","keys","serializedCakePerBracket","map","cakeInBracket","serializedCountWinnersPerBracket","winnersInBracket","serializedRewardsBreakdown","reward","isLoading","toString","processViewLotteryErrorResponse","PENDING","fetchLottery","lotteryData","viewLottery","error","fetchMultipleLotteries","lotteryIds","calls","id","name","address","params","multicallRes","requireSuccess","processedResponses","res","index","console","call","fetchCurrentLotteryIdAndMaxBuy","method","currentLotteryId","maxNumberTicketsPerBuyOrClaim","processRawTicketsResponse","ticketsResponse","ticketIds","ticketNumbers","ticketStatuses","length","ticketId","number","getViewUserTicketInfoCalls","totalTicketsToRequest","account","cursor","perRequestLimit","i","push","mergeViewUserTicketInfoMulticallResponse","mergedMulticallResponse","forEach","ticketResponse","fetchTickets","userTotalTickets","parseInt","filteredForNullResponses","filter","completeTicketData","getRoundIdsArray","currentIdAsInt","roundIds","useProcessLotteryResponse","priceTicketInCakeAsString","discountDivisorAsString","amountCollectedInCakeAsString","userTickets","hasRoundBeenClaimed","tickets","claimedTickets","ticket"],"mappings":"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","sourcesContent":["import BigNumber from 'bignumber.js'\r\nimport { ethers } from 'ethers'\r\nimport { LotteryStatus, LotteryTicket } from 'config/constants/types'\r\nimport lotteryV2Abi from 'config/abi/lotteryV2.json'\r\nimport { getLotteryV2Address } from 'utils/addressHelpers'\r\nimport { multicallv2 } from 'utils/multicall'\r\nimport { LotteryRound, UserTicketsResponse, LotteryRoundUserTickets, LotteryResponse } from 'state/types'\r\nimport { getLotteryV2Contract } from 'utils/contractHelpers'\r\nimport { useMemo } from 'react'\r\nimport { ethersToSerializedBigNumber } from 'utils/bigNumber'\r\n\r\nconst lotteryContract = getLotteryV2Contract()\r\n// Variable used to determine how many past rounds should be populated by node data rather than subgraph\r\nexport const NUM_ROUNDS_TO_FETCH_FROM_NODES = 2\r\n\r\nconst processViewLotterySuccessResponse = (response, lotteryId: string): LotteryResponse => {\r\n  const {\r\n    status,\r\n    startTime,\r\n    endTime,\r\n    priceTicketInCake,\r\n    discountDivisor,\r\n    treasuryFee,\r\n    firstTicketId,\r\n    lastTicketId,\r\n    amountCollectedInCake,\r\n    finalNumber,\r\n    cakePerBracket,\r\n    countWinnersPerBracket,\r\n    rewardsBreakdown,\r\n  } = response\r\n\r\n  const statusKey = Object.keys(LotteryStatus)[status]\r\n  const serializedCakePerBracket = cakePerBracket.map((cakeInBracket) => ethersToSerializedBigNumber(cakeInBracket))\r\n  const serializedCountWinnersPerBracket = countWinnersPerBracket.map((winnersInBracket) =>\r\n    ethersToSerializedBigNumber(winnersInBracket),\r\n  )\r\n  const serializedRewardsBreakdown = rewardsBreakdown.map((reward) => ethersToSerializedBigNumber(reward))\r\n\r\n  return {\r\n    isLoading: false,\r\n    lotteryId,\r\n    status: LotteryStatus[statusKey],\r\n    startTime: startTime?.toString(),\r\n    endTime: endTime?.toString(),\r\n    priceTicketInCake: ethersToSerializedBigNumber(priceTicketInCake),\r\n    discountDivisor: discountDivisor?.toString(),\r\n    treasuryFee: treasuryFee?.toString(),\r\n    firstTicketId: firstTicketId?.toString(),\r\n    lastTicketId: lastTicketId?.toString(),\r\n    amountCollectedInCake: ethersToSerializedBigNumber(amountCollectedInCake),\r\n    finalNumber,\r\n    cakePerBracket: serializedCakePerBracket,\r\n    countWinnersPerBracket: serializedCountWinnersPerBracket,\r\n    rewardsBreakdown: serializedRewardsBreakdown,\r\n  }\r\n}\r\n\r\nconst processViewLotteryErrorResponse = (lotteryId: string) => {\r\n  return {\r\n    isLoading: true,\r\n    lotteryId,\r\n    status: LotteryStatus.PENDING,\r\n    startTime: '',\r\n    endTime: '',\r\n    priceTicketInCake: '',\r\n    discountDivisor: '',\r\n    treasuryFee: '',\r\n    firstTicketId: '',\r\n    lastTicketId: '',\r\n    amountCollectedInCake: '',\r\n    finalNumber: null,\r\n    cakePerBracket: [],\r\n    countWinnersPerBracket: [],\r\n    rewardsBreakdown: [],\r\n  }\r\n}\r\n\r\nexport const fetchLottery = async (lotteryId: string): Promise<LotteryResponse> => {\r\n  try {\r\n    const lotteryData = await lotteryContract.viewLottery(lotteryId)\r\n    return processViewLotterySuccessResponse(lotteryData, lotteryId)\r\n  } catch (error) {\r\n    return processViewLotteryErrorResponse(lotteryId)\r\n  }\r\n}\r\n\r\nexport const fetchMultipleLotteries = async (lotteryIds: string[]): Promise<LotteryResponse[]> => {\r\n  const calls = lotteryIds.map((id) => ({\r\n    name: 'viewLottery',\r\n    address: getLotteryV2Address(),\r\n    params: [id],\r\n  }))\r\n  try {\r\n    const multicallRes = await multicallv2(lotteryV2Abi, calls, { requireSuccess: false })\r\n    const processedResponses = multicallRes.map((res, index) =>\r\n      processViewLotterySuccessResponse(res[0], lotteryIds[index]),\r\n    )\r\n    return processedResponses\r\n  } catch (error) {\r\n    console.error(error)\r\n    return calls.map((call, index) => processViewLotteryErrorResponse(lotteryIds[index]))\r\n  }\r\n}\r\n\r\nexport const fetchCurrentLotteryIdAndMaxBuy = async () => {\r\n  try {\r\n    const calls = ['currentLotteryId', 'maxNumberTicketsPerBuyOrClaim'].map((method) => ({\r\n      address: getLotteryV2Address(),\r\n      name: method,\r\n    }))\r\n    const [[currentLotteryId], [maxNumberTicketsPerBuyOrClaim]] = (await multicallv2(\r\n      lotteryV2Abi,\r\n      calls,\r\n    )) as ethers.BigNumber[][]\r\n\r\n    return {\r\n      currentLotteryId: currentLotteryId ? currentLotteryId.toString() : null,\r\n      maxNumberTicketsPerBuyOrClaim: maxNumberTicketsPerBuyOrClaim ? maxNumberTicketsPerBuyOrClaim.toString() : null,\r\n    }\r\n  } catch (error) {\r\n    return {\r\n      currentLotteryId: null,\r\n      maxNumberTicketsPerBuyOrClaim: null,\r\n    }\r\n  }\r\n}\r\n\r\nexport const processRawTicketsResponse = (ticketsResponse: UserTicketsResponse): LotteryTicket[] => {\r\n  const [ticketIds, ticketNumbers, ticketStatuses] = ticketsResponse\r\n\r\n  if (ticketIds?.length > 0) {\r\n    return ticketIds.map((ticketId, index) => {\r\n      return {\r\n        id: ticketId.toString(),\r\n        number: ticketNumbers[index].toString(),\r\n        status: ticketStatuses[index],\r\n      }\r\n    })\r\n  }\r\n  return []\r\n}\r\n\r\nexport const getViewUserTicketInfoCalls = (totalTicketsToRequest: number, account: string, lotteryId: string) => {\r\n  let cursor = 0\r\n  const perRequestLimit = 100\r\n  const calls = []\r\n\r\n  for (let i = 0; i < totalTicketsToRequest; i += perRequestLimit) {\r\n    cursor = i\r\n    calls.push({\r\n      name: 'viewUserInfoForLotteryId',\r\n      address: getLotteryV2Address(),\r\n      params: [account, lotteryId, cursor, perRequestLimit],\r\n    })\r\n  }\r\n  return calls\r\n}\r\n\r\nexport const mergeViewUserTicketInfoMulticallResponse = (response) => {\r\n  const mergedMulticallResponse: UserTicketsResponse = [[], [], []]\r\n\r\n  response.forEach((ticketResponse) => {\r\n    mergedMulticallResponse[0].push(...ticketResponse[0])\r\n    mergedMulticallResponse[1].push(...ticketResponse[1])\r\n    mergedMulticallResponse[2].push(...ticketResponse[2])\r\n  })\r\n\r\n  return mergedMulticallResponse\r\n}\r\n\r\nexport const fetchTickets = async (\r\n  account: string,\r\n  lotteryId: string,\r\n  userTotalTickets?: string,\r\n): Promise<LotteryTicket[]> => {\r\n  // If the subgraph is returning user totalTickets data for the round - use those totalTickets, if not - batch request up to 4000\r\n  const totalTicketsToRequest = userTotalTickets ? parseInt(userTotalTickets, 10) : 4000\r\n  const calls = getViewUserTicketInfoCalls(totalTicketsToRequest, account, lotteryId)\r\n  try {\r\n    const multicallRes = await multicallv2(lotteryV2Abi, calls, { requireSuccess: false })\r\n    // When using a static totalTicketsToRequest value - null responses may be returned\r\n    const filteredForNullResponses = multicallRes.filter((res) => res)\r\n    const mergedMulticallResponse = mergeViewUserTicketInfoMulticallResponse(filteredForNullResponses)\r\n    const completeTicketData = processRawTicketsResponse(mergedMulticallResponse)\r\n    return completeTicketData\r\n  } catch (error) {\r\n    console.error(error)\r\n    return null\r\n  }\r\n}\r\n\r\nexport const getRoundIdsArray = (currentLotteryId: string): string[] => {\r\n  // TODO: This returns a number, but the currentId being typed as a string is deep in the logic and needs untangling\r\n  const currentIdAsInt = parseInt(currentLotteryId, 10)\r\n  const roundIds = []\r\n  for (let i = 0; i < NUM_ROUNDS_TO_FETCH_FROM_NODES; i++) {\r\n    roundIds.push(currentIdAsInt - i)\r\n  }\r\n  return roundIds\r\n}\r\n\r\nexport const useProcessLotteryResponse = (\r\n  lotteryData: LotteryResponse & { userTickets?: LotteryRoundUserTickets },\r\n): LotteryRound => {\r\n  const {\r\n    priceTicketInCake: priceTicketInCakeAsString,\r\n    discountDivisor: discountDivisorAsString,\r\n    amountCollectedInCake: amountCollectedInCakeAsString,\r\n  } = lotteryData\r\n\r\n  const discountDivisor = useMemo(() => {\r\n    return new BigNumber(discountDivisorAsString)\r\n  }, [discountDivisorAsString])\r\n\r\n  const priceTicketInCake = useMemo(() => {\r\n    return new BigNumber(priceTicketInCakeAsString)\r\n  }, [priceTicketInCakeAsString])\r\n\r\n  const amountCollectedInCake = useMemo(() => {\r\n    return new BigNumber(amountCollectedInCakeAsString)\r\n  }, [amountCollectedInCakeAsString])\r\n\r\n  return {\r\n    isLoading: lotteryData.isLoading,\r\n    lotteryId: lotteryData.lotteryId,\r\n    userTickets: lotteryData.userTickets,\r\n    status: lotteryData.status,\r\n    startTime: lotteryData.startTime,\r\n    endTime: lotteryData.endTime,\r\n    priceTicketInCake,\r\n    discountDivisor,\r\n    treasuryFee: lotteryData.treasuryFee,\r\n    firstTicketId: lotteryData.firstTicketId,\r\n    lastTicketId: lotteryData.lastTicketId,\r\n    amountCollectedInCake,\r\n    finalNumber: lotteryData.finalNumber,\r\n    cakePerBracket: lotteryData.cakePerBracket,\r\n    countWinnersPerBracket: lotteryData.countWinnersPerBracket,\r\n    rewardsBreakdown: lotteryData.rewardsBreakdown,\r\n  }\r\n}\r\n\r\nexport const hasRoundBeenClaimed = (tickets: LotteryTicket[]): boolean => {\r\n  const claimedTickets = tickets.filter((ticket) => ticket.status)\r\n  return claimedTickets.length > 0\r\n}\r\n"]},"metadata":{},"sourceType":"module"}