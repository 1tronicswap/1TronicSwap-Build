{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$(),\n    _s8 = $RefreshSig$(),\n    _s9 = $RefreshSig$(),\n    _s10 = $RefreshSig$();\n\nimport { Pair, Token } from 'utils/@sdk';\nimport flatMap from 'lodash/flatMap';\nimport { useCallback, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { BASES_TO_TRACK_LIQUIDITY_FOR, PINNED_PAIRS } from 'config/constants';\nimport { useWeb3React } from '@web3-react/core';\nimport { useAllTokens } from 'hooks/Tokens';\nimport { addSerializedPair, addSerializedToken, removeSerializedToken, updateUserDeadline, updateUserExpertMode, updateUserSlippageTolerance, updateUserSingleHopOnly, muteAudio, unmuteAudio } from '../actions';\nimport { serializeToken, deserializeToken } from './helpers';\nexport function useAudioModeManager() {\n  _s();\n\n  const dispatch = useDispatch();\n  const audioPlay = useSelector(state => state.user.audioPlay);\n  const toggleSetAudioMode = useCallback(() => {\n    if (audioPlay) {\n      dispatch(muteAudio());\n    } else {\n      dispatch(unmuteAudio());\n    }\n  }, [audioPlay, dispatch]);\n  return [audioPlay, toggleSetAudioMode];\n}\n\n_s(useAudioModeManager, \"peXMsI6wL8RFr9b05KQwkjrw8ic=\", false, function () {\n  return [useDispatch, useSelector];\n});\n\nexport function useIsExpertMode() {\n  _s2();\n\n  return useSelector(state => state.user.userExpertMode);\n}\n\n_s2(useIsExpertMode, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\n\nexport function useExpertModeManager() {\n  _s3();\n\n  const dispatch = useDispatch();\n  const expertMode = useIsExpertMode();\n  const toggleSetExpertMode = useCallback(() => {\n    dispatch(updateUserExpertMode({\n      userExpertMode: !expertMode\n    }));\n  }, [expertMode, dispatch]);\n  return [expertMode, toggleSetExpertMode];\n}\n\n_s3(useExpertModeManager, \"ULLfsmjCcahFerd6rXziokiA+RI=\", false, function () {\n  return [useDispatch, useIsExpertMode];\n});\n\nexport function useUserSingleHopOnly() {\n  _s4();\n\n  const dispatch = useDispatch();\n  const singleHopOnly = useSelector(state => state.user.userSingleHopOnly);\n  const setSingleHopOnly = useCallback(newSingleHopOnly => {\n    dispatch(updateUserSingleHopOnly({\n      userSingleHopOnly: newSingleHopOnly\n    }));\n  }, [dispatch]);\n  return [singleHopOnly, setSingleHopOnly];\n}\n\n_s4(useUserSingleHopOnly, \"WikX7qzoMFkBpAxkb0uK96O/O0E=\", false, function () {\n  return [useDispatch, useSelector];\n});\n\nexport function useUserSlippageTolerance() {\n  _s5();\n\n  const dispatch = useDispatch();\n  const userSlippageTolerance = useSelector(state => {\n    return state.user.userSlippageTolerance;\n  });\n  const setUserSlippageTolerance = useCallback(slippage => {\n    dispatch(updateUserSlippageTolerance({\n      userSlippageTolerance: slippage\n    }));\n  }, [dispatch]);\n  return [userSlippageTolerance, setUserSlippageTolerance];\n}\n\n_s5(useUserSlippageTolerance, \"lO9PfBe6MbiNxNv0Q3TS/IyxyIE=\", false, function () {\n  return [useDispatch, useSelector];\n});\n\nexport function useUserTransactionTTL() {\n  _s6();\n\n  const dispatch = useDispatch();\n  const userDeadline = useSelector(state => {\n    return state.user.userDeadline;\n  });\n  const setUserDeadline = useCallback(deadline => {\n    dispatch(updateUserDeadline({\n      userDeadline: deadline\n    }));\n  }, [dispatch]);\n  return [userDeadline, setUserDeadline];\n}\n\n_s6(useUserTransactionTTL, \"nR4EOlfoy/fKrJpN3ITukwrTqzM=\", false, function () {\n  return [useDispatch, useSelector];\n});\n\nexport function useAddUserToken() {\n  _s7();\n\n  const dispatch = useDispatch();\n  return useCallback(token => {\n    dispatch(addSerializedToken({\n      serializedToken: serializeToken(token)\n    }));\n  }, [dispatch]);\n}\n\n_s7(useAddUserToken, \"nhyv+fhSuBJ7yx/uYuCmtG3KTzU=\", false, function () {\n  return [useDispatch];\n});\n\nexport function useRemoveUserAddedToken() {\n  _s8();\n\n  const dispatch = useDispatch();\n  return useCallback((chainId, address) => {\n    dispatch(removeSerializedToken({\n      chainId,\n      address\n    }));\n  }, [dispatch]);\n}\n\n_s8(useRemoveUserAddedToken, \"nhyv+fhSuBJ7yx/uYuCmtG3KTzU=\", false, function () {\n  return [useDispatch];\n});\n\nfunction serializePair(pair) {\n  return {\n    token0: serializeToken(pair.token0),\n    token1: serializeToken(pair.token1)\n  };\n}\n\nexport function usePairAdder() {\n  _s9();\n\n  const dispatch = useDispatch();\n  return useCallback(pair => {\n    dispatch(addSerializedPair({\n      serializedPair: serializePair(pair)\n    }));\n  }, [dispatch]);\n}\n/**\r\n * Given two tokens return the liquidity token that represents its liquidity shares\r\n * @param tokenA one of the two tokens\r\n * @param tokenB the other token\r\n */\n\n_s9(usePairAdder, \"nhyv+fhSuBJ7yx/uYuCmtG3KTzU=\", false, function () {\n  return [useDispatch];\n});\n\nexport function toV2LiquidityToken(_ref) {\n  let [tokenA, tokenB] = _ref;\n  return new Token(tokenA.chainId, Pair.getAddress(tokenA, tokenB), 18, 'Cake-LP', 'Pancake LPs');\n}\n/**\r\n * Returns all the pairs of tokens that are tracked by the user for the current chain ID.\r\n */\n\nexport function useTrackedTokenPairs() {\n  _s10();\n\n  const {\n    chainId\n  } = useWeb3React();\n  const tokens = useAllTokens(); // pinned pairs\n\n  const pinnedPairs = useMemo(() => {\n    var _PINNED_PAIRS$chainId;\n\n    return chainId ? (_PINNED_PAIRS$chainId = PINNED_PAIRS[chainId]) !== null && _PINNED_PAIRS$chainId !== void 0 ? _PINNED_PAIRS$chainId : [] : [];\n  }, [chainId]); // pairs for every token against every base\n\n  const generatedPairs = useMemo(() => chainId ? flatMap(Object.keys(tokens), tokenAddress => {\n    var _BASES_TO_TRACK_LIQUI;\n\n    const token = tokens[tokenAddress]; // for each token on the current chain,\n\n    return (// loop though all bases on the current chain\n      ((_BASES_TO_TRACK_LIQUI = BASES_TO_TRACK_LIQUIDITY_FOR[chainId]) !== null && _BASES_TO_TRACK_LIQUI !== void 0 ? _BASES_TO_TRACK_LIQUI : [] // to construct pairs of the given token with each base\n      ).map(base => {\n        if (base.address === token.address) {\n          return null;\n        }\n\n        return [base, token];\n      }).filter(p => p !== null)\n    );\n  }) : [], [tokens, chainId]); // pairs saved by users\n\n  const savedSerializedPairs = useSelector(_ref2 => {\n    let {\n      user: {\n        pairs\n      }\n    } = _ref2;\n    return pairs;\n  });\n  const userPairs = useMemo(() => {\n    if (!chainId || !savedSerializedPairs) return [];\n    const forChain = savedSerializedPairs[chainId];\n    if (!forChain) return [];\n    return Object.keys(forChain).map(pairId => {\n      return [deserializeToken(forChain[pairId].token0), deserializeToken(forChain[pairId].token1)];\n    });\n  }, [savedSerializedPairs, chainId]);\n  const combinedList = useMemo(() => userPairs.concat(generatedPairs).concat(pinnedPairs), [generatedPairs, pinnedPairs, userPairs]);\n  return useMemo(() => {\n    // dedupes pairs of tokens in the combined list\n    const keyed = combinedList.reduce((memo, _ref3) => {\n      let [tokenA, tokenB] = _ref3;\n      const sorted = tokenA.sortsBefore(tokenB);\n      const key = sorted ? `${tokenA.address}:${tokenB.address}` : `${tokenB.address}:${tokenA.address}`;\n      if (memo[key]) return memo;\n      memo[key] = sorted ? [tokenA, tokenB] : [tokenB, tokenA];\n      return memo;\n    }, {});\n    return Object.keys(keyed).map(key => keyed[key]);\n  }, [combinedList]);\n}\n\n_s10(useTrackedTokenPairs, \"lsZYBPaPlhTp94WG0fOYo790Fns=\", false, function () {\n  return [useWeb3React, useAllTokens, useSelector];\n});","map":{"version":3,"sources":["D:/new/1TronicSwap-Build/src/state/user/hooks/index.tsx"],"names":["Pair","Token","flatMap","useCallback","useMemo","useDispatch","useSelector","BASES_TO_TRACK_LIQUIDITY_FOR","PINNED_PAIRS","useWeb3React","useAllTokens","addSerializedPair","addSerializedToken","removeSerializedToken","updateUserDeadline","updateUserExpertMode","updateUserSlippageTolerance","updateUserSingleHopOnly","muteAudio","unmuteAudio","serializeToken","deserializeToken","useAudioModeManager","dispatch","audioPlay","state","user","toggleSetAudioMode","useIsExpertMode","userExpertMode","useExpertModeManager","expertMode","toggleSetExpertMode","useUserSingleHopOnly","singleHopOnly","userSingleHopOnly","setSingleHopOnly","newSingleHopOnly","useUserSlippageTolerance","userSlippageTolerance","setUserSlippageTolerance","slippage","useUserTransactionTTL","userDeadline","setUserDeadline","deadline","useAddUserToken","token","serializedToken","useRemoveUserAddedToken","chainId","address","serializePair","pair","token0","token1","usePairAdder","serializedPair","toV2LiquidityToken","tokenA","tokenB","getAddress","useTrackedTokenPairs","tokens","pinnedPairs","generatedPairs","Object","keys","tokenAddress","map","base","filter","p","savedSerializedPairs","pairs","userPairs","forChain","pairId","combinedList","concat","keyed","reduce","memo","sorted","sortsBefore","key"],"mappings":"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","sourcesContent":["import { Pair, Token } from 'utils/@sdk'\r\nimport flatMap from 'lodash/flatMap'\r\nimport { useCallback, useMemo } from 'react'\r\nimport { useDispatch, useSelector } from 'react-redux'\r\nimport { BASES_TO_TRACK_LIQUIDITY_FOR, PINNED_PAIRS } from 'config/constants'\r\nimport { useWeb3React } from '@web3-react/core'\r\nimport { useAllTokens } from 'hooks/Tokens'\r\nimport { AppDispatch, AppState } from '../../index'\r\nimport {\r\n  addSerializedPair,\r\n  addSerializedToken,\r\n  removeSerializedToken,\r\n  SerializedPair,\r\n  updateUserDeadline,\r\n  updateUserExpertMode,\r\n  updateUserSlippageTolerance,\r\n  updateUserSingleHopOnly,\r\n  muteAudio,\r\n  unmuteAudio,\r\n} from '../actions'\r\nimport { serializeToken, deserializeToken } from './helpers'\r\n\r\nexport function useAudioModeManager(): [boolean, () => void] {\r\n  const dispatch = useDispatch<AppDispatch>()\r\n  const audioPlay = useSelector<AppState, AppState['user']['audioPlay']>((state) => state.user.audioPlay)\r\n\r\n  const toggleSetAudioMode = useCallback(() => {\r\n    if (audioPlay) {\r\n      dispatch(muteAudio())\r\n    } else {\r\n      dispatch(unmuteAudio())\r\n    }\r\n  }, [audioPlay, dispatch])\r\n\r\n  return [audioPlay, toggleSetAudioMode]\r\n}\r\n\r\nexport function useIsExpertMode(): boolean {\r\n  return useSelector<AppState, AppState['user']['userExpertMode']>((state) => state.user.userExpertMode)\r\n}\r\n\r\nexport function useExpertModeManager(): [boolean, () => void] {\r\n  const dispatch = useDispatch<AppDispatch>()\r\n  const expertMode = useIsExpertMode()\r\n\r\n  const toggleSetExpertMode = useCallback(() => {\r\n    dispatch(updateUserExpertMode({ userExpertMode: !expertMode }))\r\n  }, [expertMode, dispatch])\r\n\r\n  return [expertMode, toggleSetExpertMode]\r\n}\r\n\r\nexport function useUserSingleHopOnly(): [boolean, (newSingleHopOnly: boolean) => void] {\r\n  const dispatch = useDispatch<AppDispatch>()\r\n\r\n  const singleHopOnly = useSelector<AppState, AppState['user']['userSingleHopOnly']>(\r\n    (state) => state.user.userSingleHopOnly,\r\n  )\r\n\r\n  const setSingleHopOnly = useCallback(\r\n    (newSingleHopOnly: boolean) => {\r\n      dispatch(updateUserSingleHopOnly({ userSingleHopOnly: newSingleHopOnly }))\r\n    },\r\n    [dispatch],\r\n  )\r\n\r\n  return [singleHopOnly, setSingleHopOnly]\r\n}\r\n\r\nexport function useUserSlippageTolerance(): [number, (slippage: number) => void] {\r\n  const dispatch = useDispatch<AppDispatch>()\r\n  const userSlippageTolerance = useSelector<AppState, AppState['user']['userSlippageTolerance']>((state) => {\r\n    return state.user.userSlippageTolerance\r\n  })\r\n\r\n  const setUserSlippageTolerance = useCallback(\r\n    (slippage: number) => {\r\n      dispatch(updateUserSlippageTolerance({ userSlippageTolerance: slippage }))\r\n    },\r\n    [dispatch],\r\n  )\r\n\r\n  return [userSlippageTolerance, setUserSlippageTolerance]\r\n}\r\n\r\nexport function useUserTransactionTTL(): [number, (slippage: number) => void] {\r\n  const dispatch = useDispatch<AppDispatch>()\r\n  const userDeadline = useSelector<AppState, AppState['user']['userDeadline']>((state) => {\r\n    return state.user.userDeadline\r\n  })\r\n\r\n  const setUserDeadline = useCallback(\r\n    (deadline: number) => {\r\n      dispatch(updateUserDeadline({ userDeadline: deadline }))\r\n    },\r\n    [dispatch],\r\n  )\r\n\r\n  return [userDeadline, setUserDeadline]\r\n}\r\n\r\nexport function useAddUserToken(): (token: Token) => void {\r\n  const dispatch = useDispatch<AppDispatch>()\r\n  return useCallback(\r\n    (token: Token) => {\r\n      dispatch(addSerializedToken({ serializedToken: serializeToken(token) }))\r\n    },\r\n    [dispatch],\r\n  )\r\n}\r\n\r\nexport function useRemoveUserAddedToken(): (chainId: number, address: string) => void {\r\n  const dispatch = useDispatch<AppDispatch>()\r\n  return useCallback(\r\n    (chainId: number, address: string) => {\r\n      dispatch(removeSerializedToken({ chainId, address }))\r\n    },\r\n    [dispatch],\r\n  )\r\n}\r\n\r\nfunction serializePair(pair: Pair): SerializedPair {\r\n  return {\r\n    token0: serializeToken(pair.token0),\r\n    token1: serializeToken(pair.token1),\r\n  }\r\n}\r\n\r\nexport function usePairAdder(): (pair: Pair) => void {\r\n  const dispatch = useDispatch<AppDispatch>()\r\n\r\n  return useCallback(\r\n    (pair: Pair) => {\r\n      dispatch(addSerializedPair({ serializedPair: serializePair(pair) }))\r\n    },\r\n    [dispatch],\r\n  )\r\n}\r\n\r\n/**\r\n * Given two tokens return the liquidity token that represents its liquidity shares\r\n * @param tokenA one of the two tokens\r\n * @param tokenB the other token\r\n */\r\nexport function toV2LiquidityToken([tokenA, tokenB]: [Token, Token]): Token {\r\n  return new Token(tokenA.chainId, Pair.getAddress(tokenA, tokenB), 18, 'Cake-LP', 'Pancake LPs')\r\n}\r\n\r\n/**\r\n * Returns all the pairs of tokens that are tracked by the user for the current chain ID.\r\n */\r\nexport function useTrackedTokenPairs(): [Token, Token][] {\r\n  const { chainId } = useWeb3React()\r\n  const tokens = useAllTokens()\r\n\r\n  // pinned pairs\r\n  const pinnedPairs = useMemo(() => (chainId ? PINNED_PAIRS[chainId] ?? [] : []), [chainId])\r\n\r\n  // pairs for every token against every base\r\n  const generatedPairs: [Token, Token][] = useMemo(\r\n    () =>\r\n      chainId\r\n        ? flatMap(Object.keys(tokens), (tokenAddress) => {\r\n            const token = tokens[tokenAddress]\r\n            // for each token on the current chain,\r\n            return (\r\n              // loop though all bases on the current chain\r\n              (BASES_TO_TRACK_LIQUIDITY_FOR[chainId] ?? [])\r\n                // to construct pairs of the given token with each base\r\n                .map((base) => {\r\n                  if (base.address === token.address) {\r\n                    return null\r\n                  }\r\n                  return [base, token]\r\n                })\r\n                .filter((p): p is [Token, Token] => p !== null)\r\n            )\r\n          })\r\n        : [],\r\n    [tokens, chainId],\r\n  )\r\n\r\n  // pairs saved by users\r\n  const savedSerializedPairs = useSelector<AppState, AppState['user']['pairs']>(({ user: { pairs } }) => pairs)\r\n\r\n  const userPairs: [Token, Token][] = useMemo(() => {\r\n    if (!chainId || !savedSerializedPairs) return []\r\n    const forChain = savedSerializedPairs[chainId]\r\n    if (!forChain) return []\r\n\r\n    return Object.keys(forChain).map((pairId) => {\r\n      return [deserializeToken(forChain[pairId].token0), deserializeToken(forChain[pairId].token1)]\r\n    })\r\n  }, [savedSerializedPairs, chainId])\r\n\r\n  const combinedList = useMemo(\r\n    () => userPairs.concat(generatedPairs).concat(pinnedPairs),\r\n    [generatedPairs, pinnedPairs, userPairs],\r\n  )\r\n\r\n  return useMemo(() => {\r\n    // dedupes pairs of tokens in the combined list\r\n    const keyed = combinedList.reduce<{ [key: string]: [Token, Token] }>((memo, [tokenA, tokenB]) => {\r\n      const sorted = tokenA.sortsBefore(tokenB)\r\n      const key = sorted ? `${tokenA.address}:${tokenB.address}` : `${tokenB.address}:${tokenA.address}`\r\n      if (memo[key]) return memo\r\n      memo[key] = sorted ? [tokenA, tokenB] : [tokenB, tokenA]\r\n      return memo\r\n    }, {})\r\n\r\n    return Object.keys(keyed).map((key) => keyed[key])\r\n  }, [combinedList])\r\n}\r\n"]},"metadata":{},"sourceType":"module"}