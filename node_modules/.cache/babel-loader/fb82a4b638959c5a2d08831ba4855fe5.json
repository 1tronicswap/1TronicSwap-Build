{"ast":null,"code":"import BigNumber from 'bignumber.js';\nimport { LotteryStatus } from 'config/constants/types';\nimport { multicallv2 } from 'utils/multicall';\nimport lotteryV2Abi from 'config/abi/lotteryV2.json';\nimport { getLotteryV2Address } from 'utils/addressHelpers';\nimport { BIG_ZERO } from 'utils/bigNumber';\nimport { getViewUserTicketInfoCalls, mergeViewUserTicketInfoMulticallResponse, processRawTicketsResponse } from './helpers';\nconst lotteryAddress = getLotteryV2Address();\n\nconst fetchCakeRewardsForTickets = async winningTickets => {\n  const calls = winningTickets.map(winningTicket => {\n    const {\n      roundId,\n      id,\n      rewardBracket\n    } = winningTicket;\n    return {\n      name: 'viewRewardsForTicketId',\n      address: lotteryAddress,\n      params: [roundId, id, rewardBracket]\n    };\n  });\n\n  try {\n    const cakeRewards = await multicallv2(lotteryV2Abi, calls);\n    const cakeTotal = cakeRewards.reduce((accum, cakeReward) => {\n      return accum.plus(new BigNumber(cakeReward[0].toString()));\n    }, BIG_ZERO);\n    const ticketsWithUnclaimedRewards = winningTickets.map((winningTicket, index) => {\n      return { ...winningTicket,\n        cakeReward: cakeRewards[index]\n      };\n    });\n    return {\n      ticketsWithUnclaimedRewards,\n      cakeTotal\n    };\n  } catch (error) {\n    console.error(error);\n    return {\n      ticketsWithUnclaimedRewards: null,\n      cakeTotal: null\n    };\n  }\n};\n\nconst getRewardBracketByNumber = (ticketNumber, finalNumber) => {\n  // Winning numbers are evaluated right-to-left in the smart contract, so we reverse their order for validation here:\n  // i.e. '1123456' should be evaluated as '6543211'\n  const ticketNumAsArray = ticketNumber.split('').reverse();\n  const winningNumsAsArray = finalNumber.split('').reverse();\n  const matchingNumbers = []; // The number at index 6 in all tickets is 1 and will always match, so finish at index 5\n\n  for (let index = 0; index < winningNumsAsArray.length - 1; index++) {\n    if (ticketNumAsArray[index] !== winningNumsAsArray[index]) {\n      break;\n    }\n\n    matchingNumbers.push(ticketNumAsArray[index]);\n  } // Reward brackets refer to indexes, 0 = 1 match, 5 = 6 matches. Deduct 1 from matchingNumbers' length to get the reward bracket\n\n\n  const rewardBracket = matchingNumbers.length - 1;\n  return rewardBracket;\n};\n\nexport const getWinningTickets = async roundDataAndUserTickets => {\n  const {\n    roundId,\n    userTickets,\n    finalNumber\n  } = roundDataAndUserTickets;\n  const ticketsWithRewardBrackets = userTickets.map(ticket => {\n    return {\n      roundId,\n      id: ticket.id,\n      number: ticket.number,\n      status: ticket.status,\n      rewardBracket: getRewardBracketByNumber(ticket.number, finalNumber)\n    };\n  }); // A rewardBracket of -1 means no matches. 0 and above means there has been a match\n\n  const allWinningTickets = ticketsWithRewardBrackets.filter(ticket => {\n    return ticket.rewardBracket >= 0;\n  }); // If ticket.status is true, the ticket has already been claimed\n\n  const unclaimedWinningTickets = allWinningTickets.filter(ticket => {\n    return !ticket.status;\n  });\n\n  if (unclaimedWinningTickets.length > 0) {\n    const {\n      ticketsWithUnclaimedRewards,\n      cakeTotal\n    } = await fetchCakeRewardsForTickets(unclaimedWinningTickets);\n    return {\n      ticketsWithUnclaimedRewards,\n      allWinningTickets,\n      cakeTotal,\n      roundId\n    };\n  }\n\n  if (allWinningTickets.length > 0) {\n    return {\n      ticketsWithUnclaimedRewards: null,\n      allWinningTickets,\n      cakeTotal: null,\n      roundId\n    };\n  }\n\n  return null;\n};\n\nconst getWinningNumbersForRound = (targetRoundId, lotteriesData) => {\n  const targetRound = lotteriesData.find(pastLottery => pastLottery.id === targetRoundId);\n  return targetRound === null || targetRound === void 0 ? void 0 : targetRound.finalNumber;\n};\n\nexport const fetchUserTicketsForMultipleRounds = async (roundsToCheck, account) => {\n  // Build calls with data to help with merging multicall responses\n  const callsWithRoundData = roundsToCheck.map(round => {\n    const totalTickets = parseInt(round.totalTickets, 10);\n    const calls = getViewUserTicketInfoCalls(totalTickets, account, round.lotteryId);\n    return {\n      calls,\n      lotteryId: round.lotteryId,\n      count: calls.length\n    };\n  }); // Batch all calls across all rounds\n\n  const multicalls = [].concat(...callsWithRoundData.map(callWithRoundData => callWithRoundData.calls));\n\n  try {\n    const multicallRes = await multicallv2(lotteryV2Abi, multicalls, {\n      requireSuccess: false\n    }); // Use callsWithRoundData to slice multicall responses by round\n\n    const multicallResPerRound = [];\n    let resCount = 0;\n\n    for (let i = 0; i < callsWithRoundData.length; i += 1) {\n      const callOptions = callsWithRoundData[i];\n      const singleRoundResponse = multicallRes.slice(resCount, resCount + callOptions.count); // Don't push null responses values - can happen when the check is using fallback behaviour because it has no subgraph past rounds\n\n      multicallResPerRound.push(singleRoundResponse.filter(res => res));\n      resCount += callOptions.count;\n    }\n\n    const mergedMulticallResponse = multicallResPerRound.map(res => mergeViewUserTicketInfoMulticallResponse(res));\n    return mergedMulticallResponse;\n  } catch (error) {\n    console.error(error);\n    return [];\n  }\n};\n\nconst fetchUnclaimedUserRewards = async (account, userLotteryData, lotteriesData) => {\n  const {\n    rounds\n  } = userLotteryData; // If there is no user round history - return an empty array\n\n  if (rounds.length === 0) {\n    return [];\n  } // If the web3 provider account doesn't equal the userLotteryData account, return an empty array - this is effectively a loading state as the user switches accounts\n\n\n  if (userLotteryData.account.toLowerCase() !== account.toLowerCase()) {\n    return [];\n  } // Filter out non-claimable rounds\n\n\n  const claimableRounds = rounds.filter(round => {\n    return round.status.toLowerCase() === LotteryStatus.CLAIMABLE;\n  }); // If there are any rounds tickets haven't been claimed for, OR a user has over 100 tickets in a round - check user tickets for those rounds\n\n  const roundsToCheck = claimableRounds.filter(round => {\n    return !round.claimed || parseInt(round.totalTickets, 10) > 100;\n  });\n\n  if (roundsToCheck.length > 0) {\n    const rawUserTicketData = await fetchUserTicketsForMultipleRounds(roundsToCheck, account);\n\n    if (rawUserTicketData.length === 0) {\n      // In case of error with ticket calls, return empty array\n      return [];\n    }\n\n    const roundIds = roundsToCheck.map(round => round.lotteryId);\n    const roundDataAndUserTickets = rawUserTicketData.map((rawRoundTicketData, index) => {\n      return {\n        roundId: roundIds[index],\n        userTickets: processRawTicketsResponse(rawRoundTicketData),\n        finalNumber: getWinningNumbersForRound(roundIds[index], lotteriesData)\n      };\n    });\n    const winningTicketsForPastRounds = await Promise.all(roundDataAndUserTickets.map(roundData => getWinningTickets(roundData))); // Filter out null values (returned when no winning tickets found for past round)\n\n    const roundsWithWinningTickets = winningTicketsForPastRounds.filter(winningTicketData => winningTicketData !== null); // Filter to only rounds with unclaimed tickets\n\n    const roundsWithUnclaimedWinningTickets = roundsWithWinningTickets.filter(winningTicketData => winningTicketData.ticketsWithUnclaimedRewards);\n    return roundsWithUnclaimedWinningTickets;\n  } // All rounds claimed, return empty array\n\n\n  return [];\n};\n\nexport default fetchUnclaimedUserRewards;","map":{"version":3,"sources":["D:/new/1TronicSwap-Build/src/state/lottery/fetchUnclaimedUserRewards.ts"],"names":["BigNumber","LotteryStatus","multicallv2","lotteryV2Abi","getLotteryV2Address","BIG_ZERO","getViewUserTicketInfoCalls","mergeViewUserTicketInfoMulticallResponse","processRawTicketsResponse","lotteryAddress","fetchCakeRewardsForTickets","winningTickets","calls","map","winningTicket","roundId","id","rewardBracket","name","address","params","cakeRewards","cakeTotal","reduce","accum","cakeReward","plus","toString","ticketsWithUnclaimedRewards","index","error","console","getRewardBracketByNumber","ticketNumber","finalNumber","ticketNumAsArray","split","reverse","winningNumsAsArray","matchingNumbers","length","push","getWinningTickets","roundDataAndUserTickets","userTickets","ticketsWithRewardBrackets","ticket","number","status","allWinningTickets","filter","unclaimedWinningTickets","getWinningNumbersForRound","targetRoundId","lotteriesData","targetRound","find","pastLottery","fetchUserTicketsForMultipleRounds","roundsToCheck","account","callsWithRoundData","round","totalTickets","parseInt","lotteryId","count","multicalls","concat","callWithRoundData","multicallRes","requireSuccess","multicallResPerRound","resCount","i","callOptions","singleRoundResponse","slice","res","mergedMulticallResponse","fetchUnclaimedUserRewards","userLotteryData","rounds","toLowerCase","claimableRounds","CLAIMABLE","claimed","rawUserTicketData","roundIds","rawRoundTicketData","winningTicketsForPastRounds","Promise","all","roundData","roundsWithWinningTickets","winningTicketData","roundsWithUnclaimedWinningTickets"],"mappings":"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","sourcesContent":["import BigNumber from 'bignumber.js'\r\nimport { ethers } from 'ethers'\r\nimport { LotteryStatus, LotteryTicket, LotteryTicketClaimData } from 'config/constants/types'\r\nimport { LotteryUserGraphEntity, LotteryRoundGraphEntity } from 'state/types'\r\nimport { multicallv2 } from 'utils/multicall'\r\nimport lotteryV2Abi from 'config/abi/lotteryV2.json'\r\nimport { getLotteryV2Address } from 'utils/addressHelpers'\r\nimport { BIG_ZERO } from 'utils/bigNumber'\r\nimport {\r\n  getViewUserTicketInfoCalls,\r\n  mergeViewUserTicketInfoMulticallResponse,\r\n  processRawTicketsResponse,\r\n} from './helpers'\r\n\r\ninterface RoundDataAndUserTickets {\r\n  roundId: string\r\n  userTickets: LotteryTicket[]\r\n  finalNumber: string\r\n}\r\n\r\nconst lotteryAddress = getLotteryV2Address()\r\n\r\nconst fetchCakeRewardsForTickets = async (\r\n  winningTickets: LotteryTicket[],\r\n): Promise<{ ticketsWithUnclaimedRewards: LotteryTicket[]; cakeTotal: BigNumber }> => {\r\n  const calls = winningTickets.map((winningTicket) => {\r\n    const { roundId, id, rewardBracket } = winningTicket\r\n    return {\r\n      name: 'viewRewardsForTicketId',\r\n      address: lotteryAddress,\r\n      params: [roundId, id, rewardBracket],\r\n    }\r\n  })\r\n\r\n  try {\r\n    const cakeRewards = await multicallv2(lotteryV2Abi, calls)\r\n\r\n    const cakeTotal = cakeRewards.reduce((accum: BigNumber, cakeReward: ethers.BigNumber[]) => {\r\n      return accum.plus(new BigNumber(cakeReward[0].toString()))\r\n    }, BIG_ZERO)\r\n\r\n    const ticketsWithUnclaimedRewards = winningTickets.map((winningTicket, index) => {\r\n      return { ...winningTicket, cakeReward: cakeRewards[index] }\r\n    })\r\n    return { ticketsWithUnclaimedRewards, cakeTotal }\r\n  } catch (error) {\r\n    console.error(error)\r\n    return { ticketsWithUnclaimedRewards: null, cakeTotal: null }\r\n  }\r\n}\r\n\r\nconst getRewardBracketByNumber = (ticketNumber: string, finalNumber: string): number => {\r\n  // Winning numbers are evaluated right-to-left in the smart contract, so we reverse their order for validation here:\r\n  // i.e. '1123456' should be evaluated as '6543211'\r\n  const ticketNumAsArray = ticketNumber.split('').reverse()\r\n  const winningNumsAsArray = finalNumber.split('').reverse()\r\n  const matchingNumbers = []\r\n\r\n  // The number at index 6 in all tickets is 1 and will always match, so finish at index 5\r\n  for (let index = 0; index < winningNumsAsArray.length - 1; index++) {\r\n    if (ticketNumAsArray[index] !== winningNumsAsArray[index]) {\r\n      break\r\n    }\r\n    matchingNumbers.push(ticketNumAsArray[index])\r\n  }\r\n\r\n  // Reward brackets refer to indexes, 0 = 1 match, 5 = 6 matches. Deduct 1 from matchingNumbers' length to get the reward bracket\r\n  const rewardBracket = matchingNumbers.length - 1\r\n  return rewardBracket\r\n}\r\n\r\nexport const getWinningTickets = async (\r\n  roundDataAndUserTickets: RoundDataAndUserTickets,\r\n): Promise<LotteryTicketClaimData> => {\r\n  const { roundId, userTickets, finalNumber } = roundDataAndUserTickets\r\n\r\n  const ticketsWithRewardBrackets = userTickets.map((ticket) => {\r\n    return {\r\n      roundId,\r\n      id: ticket.id,\r\n      number: ticket.number,\r\n      status: ticket.status,\r\n      rewardBracket: getRewardBracketByNumber(ticket.number, finalNumber),\r\n    }\r\n  })\r\n\r\n  // A rewardBracket of -1 means no matches. 0 and above means there has been a match\r\n  const allWinningTickets = ticketsWithRewardBrackets.filter((ticket) => {\r\n    return ticket.rewardBracket >= 0\r\n  })\r\n\r\n  // If ticket.status is true, the ticket has already been claimed\r\n  const unclaimedWinningTickets = allWinningTickets.filter((ticket) => {\r\n    return !ticket.status\r\n  })\r\n\r\n  if (unclaimedWinningTickets.length > 0) {\r\n    const { ticketsWithUnclaimedRewards, cakeTotal } = await fetchCakeRewardsForTickets(unclaimedWinningTickets)\r\n    return { ticketsWithUnclaimedRewards, allWinningTickets, cakeTotal, roundId }\r\n  }\r\n\r\n  if (allWinningTickets.length > 0) {\r\n    return { ticketsWithUnclaimedRewards: null, allWinningTickets, cakeTotal: null, roundId }\r\n  }\r\n\r\n  return null\r\n}\r\n\r\nconst getWinningNumbersForRound = (targetRoundId: string, lotteriesData: LotteryRoundGraphEntity[]) => {\r\n  const targetRound = lotteriesData.find((pastLottery) => pastLottery.id === targetRoundId)\r\n  return targetRound?.finalNumber\r\n}\r\n\r\nexport const fetchUserTicketsForMultipleRounds = async (\r\n  roundsToCheck: { totalTickets: string; lotteryId: string }[],\r\n  account: string,\r\n) => {\r\n  // Build calls with data to help with merging multicall responses\r\n  const callsWithRoundData = roundsToCheck.map((round) => {\r\n    const totalTickets = parseInt(round.totalTickets, 10)\r\n    const calls = getViewUserTicketInfoCalls(totalTickets, account, round.lotteryId)\r\n    return { calls, lotteryId: round.lotteryId, count: calls.length }\r\n  })\r\n\r\n  // Batch all calls across all rounds\r\n  const multicalls = [].concat(...callsWithRoundData.map((callWithRoundData) => callWithRoundData.calls))\r\n  try {\r\n    const multicallRes = await multicallv2(lotteryV2Abi, multicalls, { requireSuccess: false })\r\n    // Use callsWithRoundData to slice multicall responses by round\r\n    const multicallResPerRound = []\r\n    let resCount = 0\r\n    for (let i = 0; i < callsWithRoundData.length; i += 1) {\r\n      const callOptions = callsWithRoundData[i]\r\n\r\n      const singleRoundResponse = multicallRes.slice(resCount, resCount + callOptions.count)\r\n      // Don't push null responses values - can happen when the check is using fallback behaviour because it has no subgraph past rounds\r\n      multicallResPerRound.push(singleRoundResponse.filter((res) => res))\r\n      resCount += callOptions.count\r\n    }\r\n    const mergedMulticallResponse = multicallResPerRound.map((res) => mergeViewUserTicketInfoMulticallResponse(res))\r\n\r\n    return mergedMulticallResponse\r\n  } catch (error) {\r\n    console.error(error)\r\n    return []\r\n  }\r\n}\r\n\r\nconst fetchUnclaimedUserRewards = async (\r\n  account: string,\r\n  userLotteryData: LotteryUserGraphEntity,\r\n  lotteriesData: LotteryRoundGraphEntity[],\r\n): Promise<LotteryTicketClaimData[]> => {\r\n  const { rounds } = userLotteryData\r\n\r\n  // If there is no user round history - return an empty array\r\n  if (rounds.length === 0) {\r\n    return []\r\n  }\r\n\r\n  // If the web3 provider account doesn't equal the userLotteryData account, return an empty array - this is effectively a loading state as the user switches accounts\r\n  if (userLotteryData.account.toLowerCase() !== account.toLowerCase()) {\r\n    return []\r\n  }\r\n\r\n  // Filter out non-claimable rounds\r\n  const claimableRounds = rounds.filter((round) => {\r\n    return round.status.toLowerCase() === LotteryStatus.CLAIMABLE\r\n  })\r\n\r\n  // If there are any rounds tickets haven't been claimed for, OR a user has over 100 tickets in a round - check user tickets for those rounds\r\n  const roundsToCheck = claimableRounds.filter((round) => {\r\n    return !round.claimed || parseInt(round.totalTickets, 10) > 100\r\n  })\r\n\r\n  if (roundsToCheck.length > 0) {\r\n    const rawUserTicketData = await fetchUserTicketsForMultipleRounds(roundsToCheck, account)\r\n\r\n    if (rawUserTicketData.length === 0) {\r\n      // In case of error with ticket calls, return empty array\r\n      return []\r\n    }\r\n\r\n    const roundIds = roundsToCheck.map((round) => round.lotteryId)\r\n    const roundDataAndUserTickets = rawUserTicketData.map((rawRoundTicketData, index) => {\r\n      return {\r\n        roundId: roundIds[index],\r\n        userTickets: processRawTicketsResponse(rawRoundTicketData),\r\n        finalNumber: getWinningNumbersForRound(roundIds[index], lotteriesData),\r\n      }\r\n    })\r\n\r\n    const winningTicketsForPastRounds = await Promise.all(\r\n      roundDataAndUserTickets.map((roundData) => getWinningTickets(roundData)),\r\n    )\r\n\r\n    // Filter out null values (returned when no winning tickets found for past round)\r\n    const roundsWithWinningTickets = winningTicketsForPastRounds.filter(\r\n      (winningTicketData) => winningTicketData !== null,\r\n    )\r\n\r\n    // Filter to only rounds with unclaimed tickets\r\n    const roundsWithUnclaimedWinningTickets = roundsWithWinningTickets.filter(\r\n      (winningTicketData) => winningTicketData.ticketsWithUnclaimedRewards,\r\n    )\r\n\r\n    return roundsWithUnclaimedWinningTickets\r\n  }\r\n  // All rounds claimed, return empty array\r\n  return []\r\n}\r\n\r\nexport default fetchUnclaimedUserRewards\r\n"]},"metadata":{},"sourceType":"module"}