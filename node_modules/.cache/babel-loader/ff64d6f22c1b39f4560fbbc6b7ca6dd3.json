{"ast":null,"code":"import invariant from 'tiny-invariant';\nimport warning from 'tiny-warning';\nimport JSBI from 'jsbi';\nimport { getAddress } from '@ethersproject/address';\nimport { ZERO, ONE, TWO, THREE, SolidityType, SOLIDITY_TYPE_MAXIMA } from './constants';\nexport function validateSolidityTypeInstance(value, solidityType) {\n  invariant(JSBI.greaterThanOrEqual(value, ZERO), `${value} is not a ${solidityType}.`);\n  invariant(JSBI.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]), `${value} is not a ${solidityType}.`);\n} // warns if addresses are not checksummed\n\nexport function validateAndParseAddress(address) {\n  try {\n    const checksummedAddress = getAddress(address);\n    warning(address === checksummedAddress, `${address} is not checksummed.`);\n    return checksummedAddress;\n  } catch (error) {\n    invariant(false, `${address} is not a valid address.`);\n  }\n}\nexport function parseBigintIsh(bigintIsh) {\n  return bigintIsh instanceof JSBI ? bigintIsh : typeof bigintIsh === 'bigint' ? JSBI.BigInt(bigintIsh.toString()) : JSBI.BigInt(bigintIsh);\n} // mock the on-chain sqrt function\n\nexport function sqrt(y) {\n  validateSolidityTypeInstance(y, SolidityType.uint256);\n  let z = ZERO;\n  let x;\n\n  if (JSBI.greaterThan(y, THREE)) {\n    z = y;\n    x = JSBI.add(JSBI.divide(y, TWO), ONE);\n\n    while (JSBI.lessThan(x, z)) {\n      z = x;\n      x = JSBI.divide(JSBI.add(JSBI.divide(y, x), x), TWO);\n    }\n  } else if (JSBI.notEqual(y, ZERO)) {\n    z = ONE;\n  }\n\n  return z;\n} // given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\n// `maxSize` by removing the last item\n\nexport function sortedInsert(items, add, maxSize, comparator) {\n  invariant(maxSize > 0, 'MAX_SIZE_ZERO'); // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\n\n  invariant(items.length <= maxSize, 'ITEMS_SIZE'); // short circuit first item add\n\n  if (items.length === 0) {\n    items.push(add);\n    return null;\n  } else {\n    const isFull = items.length === maxSize; // short circuit if full and the additional item does not come before the last item\n\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add;\n    }\n\n    let lo = 0;\n    let hi = items.length;\n\n    while (lo < hi) {\n      const mid = lo + hi >>> 1;\n\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1;\n      } else {\n        hi = mid;\n      }\n    }\n\n    items.splice(lo, 0, add);\n    return isFull ? items.pop() : null;\n  }\n}","map":{"version":3,"sources":["D:/new/1TronicSwap-Build/src/utils/@sdk/utils.ts"],"names":["invariant","warning","JSBI","getAddress","ZERO","ONE","TWO","THREE","SolidityType","SOLIDITY_TYPE_MAXIMA","validateSolidityTypeInstance","value","solidityType","greaterThanOrEqual","lessThanOrEqual","validateAndParseAddress","address","checksummedAddress","error","parseBigintIsh","bigintIsh","BigInt","toString","sqrt","y","uint256","z","x","greaterThan","add","divide","lessThan","notEqual","sortedInsert","items","maxSize","comparator","length","push","isFull","lo","hi","mid","splice","pop"],"mappings":"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","sourcesContent":["import invariant from 'tiny-invariant'\r\nimport warning from 'tiny-warning'\r\nimport JSBI from 'jsbi'\r\nimport { getAddress } from '@ethersproject/address'\r\n\r\nimport { BigintIsh, ZERO, ONE, TWO, THREE, SolidityType, SOLIDITY_TYPE_MAXIMA } from './constants'\r\n\r\nexport function validateSolidityTypeInstance(value: JSBI, solidityType: SolidityType): void {\r\n  invariant(JSBI.greaterThanOrEqual(value, ZERO), `${value} is not a ${solidityType}.`)\r\n  invariant(JSBI.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]), `${value} is not a ${solidityType}.`)\r\n}\r\n\r\n// warns if addresses are not checksummed\r\nexport function validateAndParseAddress(address: string): string {\r\n  try {\r\n    const checksummedAddress = getAddress(address)\r\n    warning(address === checksummedAddress, `${address} is not checksummed.`)\r\n    return checksummedAddress\r\n  } catch (error) {\r\n    invariant(false, `${address} is not a valid address.`)\r\n  }\r\n}\r\n\r\nexport function parseBigintIsh(bigintIsh: BigintIsh): JSBI {\r\n  return bigintIsh instanceof JSBI\r\n    ? bigintIsh\r\n    : typeof bigintIsh === 'bigint'\r\n    ? JSBI.BigInt(bigintIsh.toString())\r\n    : JSBI.BigInt(bigintIsh)\r\n}\r\n\r\n// mock the on-chain sqrt function\r\nexport function sqrt(y: JSBI): JSBI {\r\n  validateSolidityTypeInstance(y, SolidityType.uint256)\r\n  let z: JSBI = ZERO\r\n  let x: JSBI\r\n  if (JSBI.greaterThan(y, THREE)) {\r\n    z = y\r\n    x = JSBI.add(JSBI.divide(y, TWO), ONE)\r\n    while (JSBI.lessThan(x, z)) {\r\n      z = x\r\n      x = JSBI.divide(JSBI.add(JSBI.divide(y, x), x), TWO)\r\n    }\r\n  } else if (JSBI.notEqual(y, ZERO)) {\r\n    z = ONE\r\n  }\r\n  return z\r\n}\r\n\r\n// given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\r\n// `maxSize` by removing the last item\r\nexport function sortedInsert<T>(items: T[], add: T, maxSize: number, comparator: (a: T, b: T) => number): T | null {\r\n  invariant(maxSize > 0, 'MAX_SIZE_ZERO')\r\n  // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\r\n  invariant(items.length <= maxSize, 'ITEMS_SIZE')\r\n\r\n  // short circuit first item add\r\n  if (items.length === 0) {\r\n    items.push(add)\r\n    return null\r\n  } else {\r\n    const isFull = items.length === maxSize\r\n    // short circuit if full and the additional item does not come before the last item\r\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\r\n      return add\r\n    }\r\n\r\n    let lo = 0\r\n    let hi = items.length\r\n\r\n    while (lo < hi) {\r\n      const mid = (lo + hi) >>> 1\r\n      if (comparator(items[mid], add) <= 0) {\r\n        lo = mid + 1\r\n      } else {\r\n        hi = mid\r\n      }\r\n    }\r\n    items.splice(lo, 0, add)\r\n    return isFull ? items.pop()! : null\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}